diff --git a/code-gen.ml b/code-gen.ml
index e1afb6e..7aa8c7d 100644
--- a/code-gen.ml
+++ b/code-gen.ml
@@ -1,37 +1,668 @@
-#use "semantic-analyser.ml";;
-
-(* This module is here for you convenience only!
-   You are not required to use it.
-   you are allowed to change it. *)
-module type CODE_GEN = sig
-  (* This signature assumes the structure of the constants table is
-     a list of key-value pairs:
-     - The keys are constant values (Sexpr(x) or Void)
-     - The values are pairs of:
-       * the offset from the base const_table address in bytes; and
-       * a string containing the byte representation (or a sequence of nasm macros)
-         of the constant value
-     For example: [(Sexpr(Nil), (1, "SOB_NIL"))]
-   *)
-  val make_consts_tbl : expr' list -> (constant * (int * string)) list
-
-  (* This signature assumes the structure of the fvars table is
-     a list of key-value pairs:
-     - The keys are the fvar names as strings
-     - The values are the offsets from the base fvars_table address in bytes
-     For example: [("boolean?", 0)]
-   *)  
-  val make_fvars_tbl : expr' list -> (string * int) list
-
-  (* This signature represents the idea of outputing assembly code as a string
-     for a single AST', given the full constants and fvars tables. 
-   *)
-  val generate : (constant * (int * string)) list -> (string * int) list -> expr' -> string
-end;;
-
-module Code_Gen : CODE_GEN = struct
-  let make_consts_tbl asts = raise X_not_yet_implemented;;
-  let make_fvars_tbl asts = raise X_not_yet_implemented;;
-  let generate consts fvars e = raise X_not_yet_implemented;;
-end;;
-
+#use "semantic-analyser.ml";;
+
+(* This module is here for you convenience only!
+   You are not required to use it.
+   you are allowed to change it. *)
+module type CODE_GEN = sig
+  (* This signature assumes the structure of the constants table is
+     a list of key-value pairs:
+     - The keys are constant values (Sexpr(x) or Void)
+     - The values are pairs of:
+       * the offset from the base const_table address in bytes; and
+       * a string containing the byte representation (or a sequence of nasm macros)
+         of the constant value
+     For example: [(Sexpr(Nil), (1, "SOB_NIL"))]
+   *)
+  val make_consts_tbl : expr' list -> (constant * (int * string)) list
+
+  (* This signature assumes the structure of the fvars table is
+     a list of key-value pairs:
+     - The keys are the fvar names as strings
+     - The values are the offsets from the base fvars_table address in bytes
+     For example: [("boolean?", 0)]
+   *)  
+  val make_fvars_tbl : expr' list -> (string * int) list
+
+  (* This signature represents the idea of outputing assembly code as a string
+     for a single AST', given the full constants and fvars tables. 
+   *)
+  val generate : (constant * (int * string)) list -> (string * int) list -> expr' -> string
+end;;
+
+module Code_Gen
+ : CODE_GEN 
+ = struct
+
+  type counter = { get : unit -> int;
+                     incr : unit -> unit };;
+            
+  type counter2 = { get_and_inc: int -> int;
+                    };;
+
+  (* Create Fvar Table *)
+  let rec make_fvars_tbl_single_expr index expr  = 
+
+        let rec handle_expr_list expr_list = match expr_list with
+        |[] -> []
+        |car :: cdr -> let fvars_list_rec = make_fvars_tbl_single_expr index car in fvars_list_rec @ handle_expr_list cdr in
+
+          match expr with
+          | If'(test, dit, dif) -> (make_fvars_tbl_single_expr index test)@(make_fvars_tbl_single_expr index dit)@(make_fvars_tbl_single_expr index dif)
+          | Seq'(expr_list) -> handle_expr_list expr_list
+          | Set'(expr_var, expr_val) -> (make_fvars_tbl_single_expr index expr_var)@(make_fvars_tbl_single_expr index expr_val)
+          | Def'(Var'(VarFree(str)), expr_val) -> index.incr (); [(str,index.get ())]@(make_fvars_tbl_single_expr index expr_val)
+          | Def'(expr_var, expr_val) -> (make_fvars_tbl_single_expr index expr_var)@(make_fvars_tbl_single_expr index expr_val)
+          | Or'(expr_list) -> handle_expr_list expr_list
+          | Applic'(expr, expr_list) -> (make_fvars_tbl_single_expr index expr)@(handle_expr_list expr_list)
+          | ApplicTP'(expr, expr_list) -> (make_fvars_tbl_single_expr index expr)@(handle_expr_list expr_list)
+          | LambdaSimple'(arg_list, body) -> make_fvars_tbl_single_expr index body
+          | LambdaOpt'(arg_list, opt_arg, body) -> make_fvars_tbl_single_expr index body
+          | other -> []
+          ;;
+
+let rec const_eq s1 s2 =
+  match s1, s2 with
+  | Sexpr(Bool(b1)), Sexpr(Bool(b2)) -> b1 = b2
+  | Sexpr(Nil), Sexpr(Nil) -> true
+  | Sexpr(Number(Float f1)), Sexpr(Number(Float f2)) -> abs_float(f1 -. f2) < 0.001
+  | Sexpr(Number(Int n1)), Sexpr(Number(Int n2)) -> n1 = n2
+  | Sexpr(Char(c1)), Sexpr(Char(c2)) -> c1 = c2
+  | Sexpr(String(s1)), Sexpr(String(s2)) -> s1 = s2
+  | Sexpr(Symbol(s1)), Sexpr(Symbol(s2)) -> s1 = s2
+  | Sexpr(Pair(car1, cdr1)), Sexpr(Pair(car2, cdr2)) -> (const_eq (Sexpr car1) (Sexpr car2)) && (const_eq (Sexpr cdr1) (Sexpr cdr2))
+  | Sexpr(TaggedSexpr(name1, expr1)), Sexpr(TaggedSexpr(name2, expr2)) -> (name1 = name2) && (const_eq (Sexpr expr1) (Sexpr expr2)) 
+  | Sexpr(TagRef(name1)), Sexpr(TagRef(name2)) -> name1 = name2
+  | Void, Void -> true
+  | _ -> false;;
+
+let rec print_sexpr sexpr = match sexpr with
+    | Sexpr(Nil) -> Printf.printf "Sexpr(Nil)"
+    | Sexpr(Bool(false)) -> Printf.printf "Sexpr(Bool(false))"
+    | Sexpr(Bool(true)) -> Printf.printf "Sexpr(Bool(true))"
+    | Sexpr(Number(Float f)) -> Printf.printf "Sexpr(Number(Float %f))" f
+    | Sexpr(Number(Int n)) -> Printf.printf "Sexpr(Number(Int %d))" n
+    | Sexpr(Char(char)) ->   Printf.printf "Sexpr(Char(%c))" char
+    | Sexpr(String(str)) -> Printf.printf "Sexpr(String(%s))" str
+    | Sexpr(Symbol(str)) -> Printf.printf "Sexpr(Symbol(%s))" str
+    | Sexpr(Pair(sexpr1, sexpr2)) -> Printf.printf "Sexpr(Pair(";print_sexpr (Sexpr(sexpr1)); Printf.printf ", " ; print_sexpr (Sexpr(sexpr2)); Printf.printf "))" 
+    | Sexpr(TaggedSexpr(str, sexpr1)) -> Printf.printf "Sexpr(TaggedSexpr(%s, " str; print_sexpr (Sexpr(sexpr1));Printf.printf "))";
+    | Sexpr(TagRef(str)) -> Printf.printf "Sexpr(TagRef(%s))" str 
+    | other -> Printf.printf "other" 
+          ;;
+
+(* Create Consts Table *)
+(*① Scan the AST (one recursive pass) & collect the sexprs in all Const records*)
+let rec expr_to_sexpr_list expr = 
+    let rec handle_expr_list expr_list = match expr_list with
+        |[] -> []
+        |car :: cdr -> let list_rec = expr_to_sexpr_list car in 
+         list_rec @ handle_expr_list cdr in
+
+    match expr with
+    | Const'(sexpr) -> [sexpr]
+    | If'(test, dit, dif) -> (expr_to_sexpr_list test)@(expr_to_sexpr_list dit)@(expr_to_sexpr_list dif)
+    | Seq'(expr_list) -> handle_expr_list expr_list
+    | Set'(expr_var, expr_val) -> (expr_to_sexpr_list expr_var)@(expr_to_sexpr_list expr_val)
+    | Def'(expr_var, expr_val) -> (expr_to_sexpr_list expr_var)@(expr_to_sexpr_list expr_val)
+    | Or'(expr_list) -> handle_expr_list expr_list
+    | Applic'(expr, expr_list) -> (expr_to_sexpr_list expr)@(handle_expr_list expr_list)
+    | ApplicTP'(expr, expr_list) -> (expr_to_sexpr_list expr)@(handle_expr_list expr_list)
+    | LambdaSimple'(arg_list, body) -> expr_to_sexpr_list body
+    | LambdaOpt'(arg_list, opt_arg, body) -> expr_to_sexpr_list body
+    | BoxSet'(var,expr) -> expr_to_sexpr_list expr
+    | other -> [];;
+
+let rec exprs_to_sexpr_list expr_list = match expr_list with
+|[] -> []
+|car :: cdr -> let sexpr_list = expr_to_sexpr_list car in sexpr_list @ exprs_to_sexpr_list cdr;;
+
+(* ② Convert the list to a set (removing duplicates) *)
+let rec remove_sexpr_duplicates sexpr sexpr_list =  
+match sexpr_list with
+|[] -> []
+|car :: cdr -> if const_eq car sexpr
+    then remove_sexpr_duplicates sexpr cdr
+    else [car]@remove_sexpr_duplicates sexpr cdr;;
+
+let rec convert_sexpr_list_to_set sexpr_list = match sexpr_list with
+| [] -> []
+|car :: cdr -> let list_rec = remove_sexpr_duplicates car cdr in [car]@(convert_sexpr_list_to_set list_rec)
+;;
+
+let rec rename_tagged_sexpr index sexpr = 
+match sexpr with
+| Sexpr(TaggedSexpr(name1, expr1)) -> 
+let expr_rename = rename_tagged_sexpr index (Sexpr(expr1)) in
+  (match expr_rename with
+  | Sexpr(expr) -> Sexpr(TaggedSexpr(name1^(string_of_int (index.get ())), expr))
+  | other -> Sexpr(Nil))
+| Sexpr(TagRef(name1)) ->  Sexpr(TagRef(name1^(string_of_int (index.get ()))))
+| Sexpr(Pair(car, cdr)) -> 
+let car_rename = rename_tagged_sexpr index (Sexpr(car)) in
+let cdr_rename = rename_tagged_sexpr index (Sexpr(cdr)) in
+  (match car_rename, cdr_rename with
+  | Sexpr(s1), Sexpr(s2) -> Sexpr(Pair(s1, s2))
+  | other1, other2 -> Sexpr(Nil))
+| other -> other;;
+
+let rename_tagged_sexprs sexpr_list =
+    let index =
+        let n = ref 0 in
+        { get = (fun () -> !n);
+          incr = (fun () -> n:= !n +1) } in
+
+    let rec iterate_list sexprs = 
+     match sexprs with
+    | [] -> []
+    | car :: cdr ->
+    let renamed = [rename_tagged_sexpr index car] in index.incr ();
+    renamed@(iterate_list cdr) in
+    iterate_list sexpr_list;;
+
+
+(* ③+4 Expand the list to include all sub-constants *)
+let rec expand_sub_sexpr index sexpr = match sexpr with
+| Sexpr(Pair(car, cdr)) -> 
+let new_car = (expand_sub_sexpr index (Sexpr car)) in
+let new_cdr = (expand_sub_sexpr index (Sexpr cdr)) in
+new_car@new_cdr@[Sexpr(Pair(car, cdr))]
+| Sexpr(TaggedSexpr(name1, expr1)) -> 
+(expand_sub_sexpr index (Sexpr expr1))@[Sexpr(TaggedSexpr(name1, expr1))]
+| Sexpr(TagRef(name1)) -> [Sexpr(TagRef(name1))]
+| Sexpr(Symbol(str)) -> (expand_sub_sexpr index (Sexpr(String(str)))) @[Sexpr(Symbol(str))]
+| other -> [other];;
+
+let expand_sexpr_list sexpr_list = 
+  let index =
+        let n = ref 0 in
+        { get = (fun () -> !n);
+          incr = (fun () -> n:= !n +1) } in
+let rec expand_sexpr sexprs = 
+  match sexprs with
+  |[] -> []
+  |car :: cdr -> let list_rec = expand_sub_sexpr index car in index.incr (); list_rec@(expand_sexpr cdr) in
+  expand_sexpr sexpr_list;;
+
+(* ⑤ Go over the list, from first to last, and create the
+constants-table: *)
+(* ① For each sexpr in the list, create a 3-tuple: *)
+let rec collect_tag_defs_single tag_defs_collection sexpr = 
+    (* Printf.printf "collect_tag_defs_single: "; print_sexpr sexpr; Printf.printf "\n"; *)
+
+match sexpr with
+| Sexpr(TaggedSexpr(name, expr)) -> [name, (Sexpr(expr))]
+| Sexpr(Pair(car, cdr)) -> (collect_tag_defs_single tag_defs_collection (Sexpr(car)))@(collect_tag_defs_single tag_defs_collection (Sexpr(cdr)))
+| other -> [];;
+
+
+let rec collect_tag_defs tag_defs_collection sexpr_list = match sexpr_list with
+| [] -> []
+|car :: cdr -> let list_rec = collect_tag_defs_single tag_defs_collection car in list_rec@(collect_tag_defs tag_defs_collection cdr) ;;
+
+let get_string_size str = 9 + (String.length str) ;;
+let rec get_sexpr_address tag_defs_collection first_pass acc_const_table sexpr = 
+    (* Printf.printf "get_sexpr_address: "; print_sexpr sexpr; Printf.printf "\n"; *)
+    match sexpr with
+    | Sexpr(TagRef(str)) ->  if first_pass then "dummy" else
+    let tagged_sexpr = List.assoc str tag_defs_collection in
+     get_sexpr_address tag_defs_collection first_pass acc_const_table tagged_sexpr
+    | Sexpr(TaggedSexpr(str, sexpr1)) -> get_sexpr_address tag_defs_collection first_pass acc_const_table (Sexpr(sexpr1))
+    | other -> (string_of_int (fst (List.assoc sexpr acc_const_table))) ;;
+
+let rec make_consts_tbl_single_sexpr first_pass tag_defs_collection sexpr acc_const_table index = 
+    (* (if first_pass then Printf.printf "first_pass\n" else Printf.printf "second_pass\n");
+    Printf.printf "make_consts_tbl_single_sexpr: "; print_sexpr sexpr; Printf.printf "\n"; *)
+    match sexpr with
+    | Sexpr(Number(Float f)) -> [(sexpr, (index.get_and_inc (9), "MAKE_LITERAL_FLOAT("^(string_of_float f)^")"))]
+    | Sexpr(Number(Int n)) -> [(sexpr, (index.get_and_inc (9), "MAKE_LITERAL_INTEGER("^(string_of_int n)^")"))]    
+    | Sexpr(Char(char)) -> [(sexpr, (index.get_and_inc (2), "MAKE_LITERAL_CHAR("^string_of_int (Char.code char)^")"))]   
+    | Sexpr(String(str)) -> [(sexpr, (index.get_and_inc (get_string_size str), "MAKE_LITERAL_STRING \""^str^"\""))]   
+    | Sexpr(Symbol(str)) -> [(sexpr, (index.get_and_inc (9), "MAKE_LITERAL_SYMBOL(const_tbl+"^(get_sexpr_address tag_defs_collection first_pass acc_const_table (Sexpr(String(str))))^")"))]  
+    | Sexpr(Pair(sexpr1, sexpr2)) -> [(sexpr, (index.get_and_inc (17), "MAKE_LITERAL_PAIR(const_tbl+"^(get_sexpr_address tag_defs_collection first_pass acc_const_table (Sexpr(sexpr1)))^", const_tbl+"^(get_sexpr_address tag_defs_collection first_pass acc_const_table (Sexpr(sexpr2)))^")"))]
+    | Sexpr(TaggedSexpr(str, sexpr1)) -> make_consts_tbl_single_sexpr first_pass tag_defs_collection (Sexpr(sexpr1)) acc_const_table index
+    (* | Sexpr(TagRef(str)) -> [(sexpr, (index.get_and_inc (9), "consts+"^(get_sexpr_address tag_defs_collection first_pass acc_const_table sexpr)))]    *)
+        | other -> [];;
+  
+
+
+let rec print_list = function 
+[] -> Printf.printf "()\n"
+| e::l -> print_sexpr e ; print_string " ; " ; print_list l;;
+
+let make_consts_table tag_defs_collection sexpr_list = 
+     
+          
+        let rec turn_sexpr_list_to_const_table first_pass sexpr_list_rec const_table index_rec = 
+        match sexpr_list_rec with
+        |[] -> []
+        |car :: cdr -> let list_rec = (make_consts_tbl_single_sexpr first_pass tag_defs_collection car const_table index_rec) in
+        list_rec @ (turn_sexpr_list_to_const_table first_pass cdr (const_table@list_rec) index_rec) in
+
+     let index =
+          let n = ref 6 in
+          { get_and_inc = (fun (add) -> let old = !n in n:=!n + add; old)} in
+
+    let first_pass_const_table = turn_sexpr_list_to_const_table true sexpr_list     
+    [(Void, (0, "MAKE_VOID"));
+    (Sexpr(Nil), (1, "MAKE_NIL"));
+    (Sexpr(Bool false), (2, "MAKE_BOOL(0)"));
+    (Sexpr(Bool true), (4, "MAKE_BOOL(1)"));]
+     index in
+      let index =
+          let n = ref 6 in
+          { get_and_inc = (fun (add) -> let old = !n in n:=!n + add; old)} in
+     let first_pass_const_table = [(Void, (0, "MAKE_VOID"));
+    (Sexpr(Nil), (1, "MAKE_NIL"));
+    (Sexpr(Bool false), (2, "MAKE_BOOL(0)"));
+    (Sexpr(Bool true), (4, "MAKE_BOOL(1)"));]@first_pass_const_table in
+     let second_pass_const_table = turn_sexpr_list_to_const_table false sexpr_list first_pass_const_table index
+
+     in 
+      [(Void, (0, "MAKE_VOID"));
+    (Sexpr(Nil), (1, "MAKE_NIL"));
+    (Sexpr(Bool false), (2, "MAKE_BOOL(0)"));
+    (Sexpr(Bool true), (4, "MAKE_BOOL(1)"));]@second_pass_const_table;;
+  
+
+
+
+
+
+
+
+  let make_fvars_tbl asts =
+    let index =
+            let n = ref 28 in
+            { get = (fun () -> !n);
+              incr = (fun () -> n:= !n +1) } in
+      let rec make_fvars_tbl_rec asts_rec =
+        match asts_rec with
+        |car::cdr -> 
+        let fvars_list_rec = 
+        make_fvars_tbl_single_expr index car in fvars_list_rec @ make_fvars_tbl_rec cdr
+        |[] -> [] in
+        let fvar_tbl = make_fvars_tbl_rec asts in
+        ["boolean?",0; 
+        "float?",1; "integer?",2; "pair?",3;
+        "null?",4; "char?",5; "string?",6;
+        "procedure?",7; "symbol?",8; "string-length",9;
+        "string-ref",10; "string-set!",11; "make-string",12;
+        "symbol->string",13; 
+        "char->integer",14; "integer->char",15; "eq?",16;
+        "+",17; "*",18; "-",19; "/",20; "<",21; "=",22
+        ; "car",23; "cdr",24; "cons",25; "set-car!",26; "set-cdr!",27; "apply",28]@fvar_tbl
+        ;;
+
+  let make_consts_tbl asts =
+
+      let sexpr_set = (convert_sexpr_list_to_set 
+                        (expand_sexpr_list 
+                            (convert_sexpr_list_to_set 
+                                (exprs_to_sexpr_list asts)))) in
+      (* Printf.printf "Sexpr set: "; print_list sexpr_set; Printf.printf "\n"; *)
+      let tag_defs_collection = collect_tag_defs [] sexpr_set in
+      
+       (* tag_defs_collection;; *)
+      make_consts_table tag_defs_collection sexpr_set;;
+
+(* [(Void, (0, "MAKE_VOID")); (Sexpr Nil, (1, "MAKE_NIL"));
+ (Sexpr (Bool false), (2, "MAKE_BOOL(0)"));
+ (Sexpr (Bool true), (4, "MAKE_BOOL(1)"));
+ (Sexpr (TagRef "x0"), (6, "consts+67"));
+ (Sexpr (Number (Int 2)), (15, "MAKE_LITERAL_INTEGER(2)"));
+ (Sexpr (Number (Int 2)), (24, "MAKE_LITERAL_INTEGER(2)"));
+ (Sexpr (Pair (TaggedSexpr ("y0", Number (Int 2)), Nil)),
+  (33, "MAKE_LITERAL_PAIR(const_tbl+15, const_tbl+1)"));
+ (Sexpr (Pair (Pair (TaggedSexpr ("y0", Number (Int 2)), Nil), Nil)),
+  (50, "MAKE_LITERAL_PAIR(const_tbl+33, const_tbl+1)"));
+ (Sexpr
+   (Pair (TagRef "x0",
+     Pair (Pair (TaggedSexpr ("y0", Number (Int 2)), Nil), Nil))),
+  (67, "MAKE_LITERAL_PAIR(const_tbl+67, const_tbl+50)"));
+ (Sexpr
+   (Pair (TagRef "x0",
+     Pair (Pair (TaggedSexpr ("y0", Number (Int 2)), Nil), Nil))),
+  (84, "MAKE_LITERAL_PAIR(const_tbl+67, const_tbl+50)"))] *)
+
+  let generate_const consts const = 
+      (* Printf.printf "const:" ; print_sexpr const; Printf.printf "\n"; *)
+      let const_address =
+      match const with 
+      | Sexpr(TaggedSexpr(name, sexpr)) -> (string_of_int (fst (List.assoc (Sexpr(sexpr)) consts)))
+      | other -> (string_of_int (fst (List.assoc const consts))) in
+
+          (* Printf.printf "const success: \n" ; *)
+    ";GENERATE CONST:\n" ^
+    " mov rax, const_tbl+" ^ const_address ^ "\n ;<end const> \n";;
+
+  let generate_param_get minor = 
+    ";GENERATE PARAM GET:\n" ^
+    "mov rax, qword [rbp + "^ (string_of_int (8 * (4 + minor))) ^"] \n ;<end param get> \n";;
+
+  let generate_bound_get major minor = 
+    ";GENERATE BOUND GET:\n" ^
+    "mov rax, qword [rbp + " ^ string_of_int (8 * 2)^"]
+    mov rax, qword [rax + "^ string_of_int (8*major) ^"]
+    mov rax, qword [rax + "^ string_of_int (8*minor) ^"] \n ;<end bound get> \n";;
+
+  let generate_fvar fvars v = 
+    let index_in_fvar_table = (string_of_int (List.assoc v fvars)) in
+    ";GENERATE FVAR:\n" ^
+    "mov rax, qword [fvar_tbl+"^string_of_int (8*int_of_string index_in_fvar_table)^"] \n ;<end fvar> \n";;
+
+  let label_index =
+    let n = ref 0 in
+    { get = (fun () -> !n);
+      incr = (fun () -> n:= !n +1) } 
+
+  let rec generate_wrap env_size consts fvars e = match e with
+    | Const'(const) -> generate_const consts const
+    | Var'(VarParam(_, minor)) -> generate_param_get minor
+    | Set'(Var'(VarParam(_, minor)),expr) -> generate_param_set env_size consts fvars minor expr
+    | Var'(VarBound(_, major, minor)) -> generate_bound_get major minor
+    | Set'(Var'(VarBound(_,major,minor)),expr) -> generate_bound_set env_size consts fvars major minor expr
+    | Var'(VarFree(v)) -> generate_fvar fvars v
+    | Set'(Var'(VarFree(v)),expr) -> generate_fvar_set env_size consts fvars v expr
+    | Def'(Var'(var),expr) -> generate_def env_size consts fvars var expr
+    | Seq'(expr_list) -> generate_seq env_size consts fvars expr_list
+    | Or'(expr_list) -> generate_or env_size consts fvars expr_list
+    | If'(expr1,expr2,expr3) -> generate_if env_size consts fvars expr1 expr2 expr3
+    | BoxGet'(var) -> generate_box_get env_size consts fvars var
+    | BoxSet'(var,expr) -> generate_box_set env_size consts fvars var expr
+    | Box'(var) -> generate_box env_size consts fvars var
+    | LambdaSimple'(string_list,body) -> generate_simple_lambda (env_size+1) consts fvars string_list body false
+    | LambdaOpt'(string_list,string,body) -> generate_simple_lambda (env_size+1) consts fvars string_list body true
+    | Applic'(expr,expr_list) -> generate_applic env_size consts fvars expr expr_list
+    | ApplicTP'(expr,expr_list) -> generate_applic env_size consts fvars expr expr_list
+    | other -> ""
+  and generate_param_set env_size consts fvars minor expr =
+    let generated_expr = generate_wrap env_size consts fvars expr in
+    ";GENERATE PARAM SET:\n" ^
+    generated_expr ^
+    "mov qword [rbp + " ^ string_of_int (8 * ( 4 + minor))^"], rax
+    mov rax, SOB_VOID_ADDRESS \n ;<end param set> \n"
+  and generate_bound_set env_size consts fvars major minor expr =
+    let generated_expr = generate_wrap env_size consts fvars expr in
+    ";GENERATE BOUND SET:\n" ^
+    generated_expr ^
+    "mov rbx, qword [rbp + "^ string_of_int (8 * 2)^"]
+    mov rbx, qword [rbx + " ^ string_of_int (8 * major) ^"]
+    mov qword [rbx +  " ^ string_of_int (8 * minor) ^"], rax
+    mov rax, SOB_VOID_ADDRESS \n ;<end bound set> \n"
+  and generate_fvar_set env_size consts fvars v expr =
+    let generated_expr = generate_wrap env_size consts fvars expr in
+    let index_in_fvar_table = (string_of_int (List.assoc v fvars)) in
+    ";GENERATE FVAR SET:\n" ^
+    generated_expr ^
+    "mov qword [fvar_tbl+"^string_of_int (8*int_of_string index_in_fvar_table)^"], rax
+    mov rax, SOB_VOID_ADDRESS \n ;<end fvar set> \n"
+  and generate_seq env_size consts fvars expr_list =
+    ";GENERATE SEQUENCE:\n" ^
+    (List.fold_right (fun a b -> (generate_wrap env_size consts fvars) a ^  b) expr_list "")
+    ^ "; <end sequence> \n"
+  and generate_or env_size consts fvars expr_list =
+    label_index.incr ();
+    let curr_index = label_index.get () in
+    let or_fold_fun = (fun a b -> 
+    ((generate_wrap env_size consts fvars) a) ^
+    "cmp rax, SOB_FALSE_ADDRESS
+    jne Lexit"^string_of_int curr_index^" \n\n" ^  b) in
+    ";GENERATE OR:\n" ^
+    List.fold_right or_fold_fun expr_list ""
+    ^"Lexit" ^(string_of_int curr_index) ^ ":\n ;<end or> \n"
+  and generate_if env_size consts fvars test dit dif = 
+    label_index.incr ();
+    let curr_index = label_index.get () in
+    let generated_test = generate_wrap env_size consts fvars test in
+    let generated_dit = generate_wrap env_size consts fvars dit in
+    let generated_dif = generate_wrap env_size consts fvars dif in
+    ";GENERATE IF:\n" ^
+    generated_test ^
+    "cmp rax, SOB_FALSE_ADDRESS
+    je Lelse"^string_of_int curr_index ^ "\n" ^
+    generated_dit ^ "\n" ^
+    "jmp Lexit"^string_of_int curr_index^"\n" ^
+    "Lelse"^string_of_int curr_index^":\n" ^
+    generated_dif ^ "\n" ^
+    "Lexit"^string_of_int curr_index^":\n ;<end if> \n"
+  and  generate_box_get env_size consts fvars var = 
+    let generated_var = generate_wrap env_size consts fvars (Var'(var)) in
+    ";GENERATE BOX GET:\n" ^
+    generated_var ^
+    "mov rax, qword [rax] \n ;<end box get> \n"
+  and  generate_box_set env_size consts fvars var expr = 
+    let generated_expr = generate_wrap env_size consts fvars expr in
+    let generated_var = generate_wrap env_size consts fvars (Var'(var)) in
+    ";GENERATE BOX SET:\n" ^
+    generated_expr ^
+    "push rax \n" ^
+    generated_var ^
+    "pop qword [rax]
+    mov rax, SOB_VOID_ADDRESS \n ;<end box set> \n"
+  and generate_box env_size consts fvars var = 
+  let generated_var = generate_wrap env_size consts fvars (Var'(var)) in
+  ";GENERATE BOX:\n" ^
+  "MALLOC r8, 8 \n" ^
+   generated_var ^
+   "mov qword [r8], rax
+   mov rax, r8 \n ;<end box> \n"
+  and generate_def env_size consts fvars var expr = 
+  ";GENERATE DEFINE\n" ^
+  (match var with
+    |VarBound(_,major,minor) -> generate_bound_set env_size consts fvars major minor expr
+    |VarParam(_, minor) -> generate_param_set env_size consts fvars minor expr
+    |VarFree(v) -> generate_fvar_set env_size consts fvars v expr
+  ) ^ "\n ;<end define> \n"
+  and generate_simple_lambda env_size consts fvars string_list body opt_flag =
+    label_index.incr ();
+    if env_size=0 then generate_first_simple_lambda env_size consts fvars string_list body opt_flag else
+    let curr_index = label_index.get () in 
+    let generated_body = generate_wrap env_size consts fvars body in
+    let allocate_env_code =
+    "MALLOC rax, " ^ (string_of_int (8*env_size)) ^ "\n" in
+    let extend_env_code = 
+    "mov r9, rax ;r9 points at env[0]
+    mov r8, qword [rbp+16] ;r8 points at the source env
+    add rax, 8 ; rax points at env[1]
+    mov rcx, " ^ (string_of_int env_size) ^ "
+    cmp rcx, 1
+    je end_extend_env_loop_" ^ (string_of_int curr_index) ^ "
+    
+    extend_env_loop_" ^ (string_of_int curr_index) ^ ":
+    mov r10, qword [r8]
+    mov qword [rax], r10
+    add r8, 8
+    add rax, 8
+    loop extend_env_loop_" ^ (string_of_int curr_index) ^ "
+    
+    end_extend_env_loop_" ^ (string_of_int curr_index) ^ ":\n"
+     in
+    let copy_params_to_env = 
+    "
+    push r9
+    mov rcx, qword [rbp+8*3] 
+    inc rcx ;include magic params
+    shl rcx, 3 ;rcx = size of params list (including magic)
+    MALLOC rax, rcx ;allocate room for param list
+    mov qword [rax], SOB_NIL_ADDRESS ;param list is empty by default
+    pop r9
+    mov qword [r9], rax ;place pointer to param list in env[0]
+
+    shr rcx, 3 ;rcx holds num of params
+    cmp rcx, 0              
+    je end_copy_param_loop_"^(string_of_int curr_index) ^"
+    mov r10, rbp
+    add r10, 8*4 ;r10 points to beginning of param list on stack
+
+    copy_param_loop_"^(string_of_int curr_index) ^":
+    mov r11, qword [r10]
+    mov qword [rax], r11
+    add r10, 8
+    add rax, 8
+    loop copy_param_loop_"^(string_of_int curr_index) ^"
+
+    end_copy_param_loop_"^(string_of_int curr_index) ^": \n" in
+    let body_label = 
+    "lambda_body_"^(string_of_int curr_index) ^":\n" ^
+        (* (if opt_flag then (generate_opt_lambda env_size consts fvars string_list body curr_index) else "") ^ *)
+    "push rbp
+    mov rbp,rsp \n" ^ 
+    (if opt_flag then (generate_opt_lambda env_size consts fvars string_list body curr_index) else "") ^
+    generated_body ^ "
+    leave
+    ret\n" in
+    let closure_code = 
+    "MAKE_CLOSURE(rax, r9,lambda_body_"^(string_of_int curr_index)^")
+    jmp end_lambda_body_"^(string_of_int curr_index)^"\n" ^
+    body_label ^
+    "end_lambda_body_"^(string_of_int curr_index)^":\n" in
+    ";GENERATE SIMPLE LAMBDA:\n" ^allocate_env_code ^ extend_env_code ^ copy_params_to_env ^ closure_code ^ "\n ;<end simple lambda> \n"
+  and generate_first_simple_lambda env_size consts fvars string_list body opt_flag= 
+    let curr_index = label_index.get () in
+    let generated_body = generate_wrap env_size consts fvars body in
+    let body_label = 
+    "lambda_body_"^(string_of_int curr_index) ^":\n" ^
+        (* (if opt_flag then (generate_opt_lambda env_size consts fvars string_list body curr_index) else "") ^ *)
+    "push rbp
+    mov rbp,rsp \n" ^
+    (if opt_flag then (generate_opt_lambda env_size consts fvars string_list body curr_index) else "") ^
+    generated_body ^ "
+    leave
+    ret\n" in
+    ";GENERATE FIRST SIMPLE LAMBDA:\n" ^
+    "MAKE_CLOSURE(rax, SOB_NIL_ADDRESS,lambda_body_"^(string_of_int curr_index)^")
+    jmp end_lambda_body_"^(string_of_int curr_index)^"\n" ^
+    body_label ^
+    "end_lambda_body_"^(string_of_int curr_index)^": \n ;<end first simple lambda> \n"
+  and generate_applic env_size consts fvars expr expr_list = 
+
+    let push_magic = 
+    "mov rax, SOB_NIL_ADDRESS
+    push rax \n" in
+    let push_generated_expr_list =    
+     (List.fold_right (fun expr acc -> acc ^ ((generate_wrap env_size consts fvars) expr) ^ "push rax \n") expr_list "") in
+    let push_args_num = "push " ^ string_of_int (List.length expr_list) ^ "\n" in
+    let generated_expr = generate_wrap env_size consts fvars expr in
+    (* let validate_closure = 
+    "xor r8, r8
+    mov r8b, word [rax]
+    cmp r8b, T_CLOSURE
+    jne end_applic_" ^ string_of_int curr_index ^ "\n" in *)
+    let push_env = 
+    "CLOSURE_ENV r9, rax
+    push r9 \n" in
+    let execute_code = 
+    "CLOSURE_CODE r10, rax
+
+    call r10\n" in
+    let clean_stack = 
+    "
+    add rsp , 8*1 ; pop env
+    pop rbx ; pop arg count + magic
+    add rbx, 1
+    shl rbx , 3 ; rbx = rbx * 8
+    add rsp , rbx; pop args\n ;<end applic> \n" in
+    ";GENERATE APPLIC\n" ^ push_magic ^ push_generated_expr_list ^ push_args_num ^ generated_expr
+    ^ push_env ^ execute_code ^ clean_stack 
+    and generate_opt_lambda env_size consts fvars string_list body label_index =
+      let save_n = 
+      "mov r8, qword [rbp+8*3] ; r8 = n \n" in
+      let save_expected_args = "mov r9, "^string_of_int (List.length string_list) ^" ; r9 = expected \n" in
+      let opt_list_size = 
+      "mov r10, r8
+      sub r10, r9 ; r10 = list size = n - expected
+      cmp r10, 0
+      je end_lambda_opt_"^ (string_of_int label_index) ^"\n"
+       in
+      let first_unexpected = 
+      "mov rax, r9 ; rax = expected
+      add rax, 4 ; rax = expected+4
+      shl rax, 3 ; rax = (expected+4)*8
+      add rax, rbp ; rax = rbp + (expected+4)*8
+      mov r11, rax ; r11 points to first opt arg\n"
+      in
+      let alloc_opt_list = 
+          "MAKE_PAIR(rax, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS)
+          mov r9, rax ; r9 points to opt list\n" in
+      let build_opt_list =
+          "mov rcx, r10
+          build_opt_list_" ^(string_of_int label_index)^":
+          mov r12, qword [r11] ; r12 = curr arg
+          mov qword [rax + 1], r12 ; place curr arg in curr car
+          cmp rcx, 1
+          je end_build_opt_list_"^(string_of_int label_index)^"
+          MAKE_PAIR (r13, SOB_NIL_ADDRESS, SOB_NIL_ADDRESS) 
+          mov qword [rax + 9], r13
+          add rax, 17
+          add r11, 8
+          loop build_opt_list_" ^(string_of_int label_index)^"
+          end_build_opt_list_"^(string_of_int label_index)^":
+          mov PVAR("^string_of_int ((List.length string_list))^"), r9 ; first opt arg has been replaced with a pointer to the opt_list
+          end_lambda_opt_"^ (string_of_int label_index) ^":\n" in
+        ";GENERATE LAMBDA OPT:\n" ^ save_n ^ save_expected_args ^ opt_list_size ^ first_unexpected ^ alloc_opt_list ^ build_opt_list ^ ";end lambda opt>\n"
+    and generate_tp_applic env_size consts fvars expr expr_list = 
+          label_index.incr ();
+          let curr_index = label_index.get () in
+          let push_magic = 
+          "mov rax, SOB_NIL_ADDRESS
+          push rax \n" in
+          let push_generated_expr_list =    
+          (List.fold_right (fun expr acc -> acc ^ ((generate_wrap env_size consts fvars) expr) ^ "push rax \n") expr_list "") in
+          let push_args_num = "push " ^ string_of_int (List.length expr_list) ^ "\n" in
+          let generated_expr = generate_wrap env_size consts fvars expr in
+          let push_env = 
+          "CLOSURE_ENV r9, rax
+          push r9 \n" in
+          let push_old_ret = 
+          "push qword [rbp + 8 * 1] ;push old ret address
+          mov r15, rax\n" in
+          let fix_stack = 
+          "mov r8, qword [rbp]
+           mov rax, PARAM_COUNT
+           mov r12, PARAM_COUNT
+           add rax, 5 ; rax = n (old) +5
+           mov rcx, " ^ string_of_int ((List.length expr_list) + 5)^ " ; rcx = m (new) + 5
+           mov r14, rax
+           add r13, 1 ; running index
+           override_old_frame_"^ string_of_int curr_index^":
+            dec rax
+            mov r9, rbp
+            mov r10, r13
+            shl r10, 3
+            sub r9, r10 ; r9 = rbp - 8*i
+            mov r11, [r9]
+            mov [rbp+8*rax], r11
+            inc r13
+            loop override_old_frame_"^ string_of_int curr_index^"
+            
+            mov rcx, " ^ string_of_int ((List.length expr_list))^ " ; rcx = m (new)
+            sub rcx, r12 ; rcx = m-n
+            shl rcx, 3 ; rcx = 8(m-n)
+            mov r12, rbp
+            sub r12, rcx ; rax = rbp - 8(m-n)
+            mov rsp, r12\n" (*remove end loop*)
+          in
+
+          let execute_code = 
+          "mov rax, r15
+          CLOSURE_CODE r10, rax
+          add rsp, 8
+          mov rbp, r8
+          jmp r10\n" in
+              (* let clean_stack = 
+          "add rsp , 8*1 ; pop env
+          pop rbx ; pop arg count + magic
+          add rbx, 1
+          shl rbx , 3 ; rbx = rbx * 8
+          add rsp , rbx; pop args\n ;<end applic> \n" in *)
+          ";GENERATE APPLIC TP:\n" ^ push_magic ^ push_generated_expr_list ^ push_args_num ^ generated_expr
+          ^ push_env ^push_old_ret^ fix_stack^ execute_code 
+          
+          ;;
+
+
+  let generate consts fvars e = 
+    generate_wrap (-1) consts fvars e;;
+
+end;;
+
diff --git a/compiler.ml b/compiler.ml
index 291b188..f9f8f45 100644
--- a/compiler.ml
+++ b/compiler.ml
@@ -1,121 +1,170 @@
-#use "code-gen.ml";;
-
-let file_to_string f =
-  let ic = open_in f in
-  let s = really_input_string ic (in_channel_length ic) in
-  close_in ic;
-  s;;
-
-let string_to_asts s = List.map Semantics.run_semantics
-                         (Tag_Parser.tag_parse_expressions
-                            (Reader.read_sexprs s));;
-
-let primitive_names_to_labels = 
-  ["boolean?", "is_boolean"; "float?", "is_float"; "integer?", "is_integer"; "pair?", "is_pair";
-   "null?", "is_null"; "char?", "is_char"; "string?", "is_string";
-   "procedure?", "is_procedure"; "symbol?", "is_symbol"; "string-length", "string_length";
-   "string-ref", "string_ref"; "string-set!", "string_set"; "make-string", "make_string";
-   "symbol->string", "symbol_to_string"; 
-   "char->integer", "char_to_integer"; "integer->char", "integer_to_char"; "eq?", "is_eq";
-   "+", "bin_add"; "*", "bin_mul"; "-", "bin_sub"; "/", "bin_div"; "<", "bin_lt"; "=", "bin_equ"
-(* you can add yours here *)];;
-
-let make_prologue consts_tbl fvars_tbl =
-  let make_primitive_closure (prim, label) =
-    (* Adapt the addressing here to your fvar addressing scheme:
-       This imlementation assumes fvars are offset from the base label fvar_tbl *)
-"    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")
-    mov [fvar_tbl+" ^  (string_of_int (List.assoc prim fvars_tbl)) ^ "], rax" in
-  let constant_bytes (c, (a, s)) = s in
-"
-;;; All the macros and the scheme-object printing procedure
-;;; are defined in compiler.s
-%include \"compiler.s\"
-
-section .bss
-;;; This pointer is used to manage allocations on our heap.
-malloc_pointer:
-    resq 1
-
-section .data
-const_tbl:
-" ^ (String.concat "\n" (List.map constant_bytes consts_tbl)) ^ "
-
-;;; These macro definitions are required for the primitive
-;;; definitions in the epilogue to work properly
-%define SOB_VOID_ADDRESS const_tbl+" ^ (string_of_int (fst (List.assoc Void consts_tbl))) ^ "
-%define SOB_NIL_ADDRESS const_tbl+" ^ (string_of_int (fst (List.assoc (Sexpr Nil) consts_tbl))) ^ "
-%define SOB_FALSE_ADDRESS const_tbl+" ^ (string_of_int (fst (List.assoc (Sexpr (Bool false)) consts_tbl))) ^ "
-%define SOB_TRUE_ADDRESS const_tbl+" ^ (string_of_int  (fst (List.assoc (Sexpr (Bool true)) consts_tbl))) ^ "
-
-fvar_tbl:
-" ^
-  (* This line should be adapted to your fvar-addressing scheme. 
-     I.e., if you use direct labeling, you should output them here. *)
-  (String.concat "\n" (List.map (fun _ -> "dq T_UNDEFINED") fvars_tbl)) ^ "
-
-global main
-section .text
-main:
-    push rbp
-
-    ;; set up the heap
-    mov rdi, GB(4)
-    call malloc
-    mov [malloc_pointer], rax
-
-    ;; Set up the dummy activation frame
-    ;; The dummy return address is T_UNDEFINED
-    ;; (which a is a macro for 0) so that returning
-    ;; from the top level (which SHOULD NOT HAPPEN
-    ;; AND IS A BUG) will cause a segfault.
-    push 0
-    push qword SOB_NIL_ADDRESS
-    push qword T_UNDEFINED
-    push rsp
-    mov rbp,rsp
-
-    ;; Set up the primitive stdlib fvars:
-    ;; Since the primtive procedures are defined in assembly,
-    ;; they are not generated by scheme (define ...) expressions.
-    ;; This is where we emulate the missing (define ...) expressions
-    ;; for all the primitive procedures.
-" ^ (String.concat "\n" (List.map make_primitive_closure primitive_names_to_labels)) ^ "
-
-user_code_fragment:
-;;; The code you compiled will be catenated here.
-;;; It will be executed immediately after the closures for 
-;;; the primitive procedures are set up.
-
-";;
-
-(* You may populate this variable with a string containing the epilogue.
-   You may load it from a file, you may write it here inline, 
-   you may just add things to prims.s (which gets catenated with the epilogue variable).
-   Whatever floats your boat. You just have to make sure all the required
-   primitive procedures are implemented and included in the output assembly. *)
-let epilogue = "";;
-
-exception X_missing_input_file;;
-
-try
-  let infile = Sys.argv.(1) in
-  let code =  (file_to_string "stdlib.scm") ^ (file_to_string infile) in
-  let asts = string_to_asts code in
-  let consts_tbl = Code_Gen.make_consts_tbl asts in
-  let fvars_tbl = Code_Gen.make_fvars_tbl asts in
-  let generate = Code_Gen.generate consts_tbl fvars_tbl in
-  let code_fragment = String.concat "\n\n"
-                        (List.map
-                           (fun ast -> (generate ast) ^ "\n\tcall write_sob_if_not_void")
-                           asts) in
-  (* clean_exit contains instructions to clean the dummy stack
-     and return exit code 0 ("all's well") from procedure main. *)
-  let clean_exit = "\n\n\tmov rax, 0\n\tadd rsp, 4*8\n\tpop rbp\n\tret\n\n" in
-  let provided_primitives = file_to_string "prims.s" in
-                   
-  print_string ((make_prologue consts_tbl fvars_tbl)  ^
-                  code_fragment ^ clean_exit ^
-                    provided_primitives ^ "\n" ^ epilogue)
-
-with Invalid_argument(x) -> raise X_missing_input_file;;
+#use "code-gen.ml";;
+
+let file_to_string f =
+  let ic = open_in f in
+  let s = really_input_string ic (in_channel_length ic) in
+  close_in ic;
+  s;;
+
+let string_to_asts s = List.map Semantics.run_semantics
+                         (Tag_Parser.tag_parse_expressions
+                            (Reader.read_sexprs s));;
+
+let primitive_names_to_labels = 
+  ["boolean?", "is_boolean"; 
+  "float?", "is_float"; "integer?", "is_integer"; "pair?", "is_pair";
+   "null?", "is_null"; "char?", "is_char"; "string?", "is_string";
+   "procedure?", "is_procedure"; "symbol?", "is_symbol"; "string-length", "string_length";
+   "string-ref", "string_ref"; "string-set!", "string_set"; "make-string", "make_string";
+   "symbol->string", "symbol_to_string"; 
+   "char->integer", "char_to_integer"; "integer->char", "integer_to_char"; "eq?", "is_eq";
+   "+", "bin_add"; "*", "bin_mul"; "-", "bin_sub"; "/", "bin_div"; "<", "bin_lt"; "=", "bin_equ"
+   ; "car", "car_label" ; "cdr", "cdr_label" ; "cons", "cons_label" ; "set-car!", "set_car_label" ; "set-cdr!", "set_cdr_label"
+  ; "apply", "apply_label"];;
+
+let make_prologue consts_tbl fvars_tbl =
+  let make_primitive_closure (prim, label) = 
+    (* Adapt the addressing here to your fvar addressing scheme:
+       This imlementation assumes fvars are offset from the base label fvar_tbl *)
+"    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")
+    mov [fvar_tbl+ 8 * " ^  (string_of_int (List.assoc prim fvars_tbl)) ^ "], rax" in 
+  let constant_bytes (c, (a, s)) = s in 
+"
+;;; All the macros and the scheme-object printing procedure
+;;; are defined in compiler.s
+%include \"compiler.s\"
+
+section .bss
+;;; This pointer is used to manage allocations on our heap.
+malloc_pointer:
+    resq 1
+
+section .data
+
+%macro MAKE_LITERAL 2 ; Make a literal of type %1
+; followed by the definition %2
+db %1
+%2
+%endmacro
+
+const_tbl:
+" ^ (String.concat "\n" (List.map constant_bytes consts_tbl)) ^ "
+
+;;; These macro definitions are required for the primitive
+;;; definitions in the epilogue to work properly
+%define SOB_VOID_ADDRESS const_tbl+" ^ (string_of_int (fst (List.assoc Void consts_tbl))) ^ "
+%define SOB_NIL_ADDRESS const_tbl+" ^ (string_of_int (fst (List.assoc (Sexpr Nil) consts_tbl))) ^ "
+%define SOB_FALSE_ADDRESS const_tbl+" ^ (string_of_int (fst (List.assoc (Sexpr (Bool false)) consts_tbl))) ^ "
+%define SOB_TRUE_ADDRESS const_tbl+" ^ (string_of_int  (fst (List.assoc (Sexpr (Bool true)) consts_tbl))) ^ "
+
+fvar_tbl:
+" ^ 
+  (* This line should be adapted to your fvar-addressing scheme. 
+     I.e., if you use direct labeling, you should output them here. *)
+  (String.concat "\n" (List.map (fun _ -> "dq T_UNDEFINED") fvars_tbl)) ^ "
+
+global main
+section .text
+main:
+    push rbp
+
+    ;; set up the heap
+    mov rdi, GB(4)
+    call malloc
+    mov [malloc_pointer], rax
+
+    ;; Set up the dummy activation frame
+    ;; The dummy return address is T_UNDEFINED
+    ;; (which a is a macro for 0) so that returning
+    ;; from the top level (which SHOULD NOT HAPPEN
+    ;; AND IS A BUG) will cause a segfault.
+    push 0
+    push qword SOB_NIL_ADDRESS
+    push qword T_UNDEFINED
+    push rsp
+    mov rbp,rsp
+
+    ;; Set up the primitive stdlib fvars:
+    ;; Since the primtive procedures are defined in assembly,
+    ;; they are not generated by scheme (define ...) expressions.
+    ;; This is where we emulate the missing (define ...) expressions
+    ;; for all the primitive procedures.
+" 
+^ (String.concat "\n" (List.map make_primitive_closure primitive_names_to_labels)) ^ "
+
+user_code_fragment:
+;;; The code you compiled will be catenated here.
+;;; It will be executed immediately after the closures for 
+;;; the primitive procedures are set up.
+
+"
+;;
+
+(* You may populate this variable with a string containing the epilogue.
+   You may load it from a file, you may write it here inline, 
+   you may just add things to prims.s (which gets catenated with the epilogue variable).
+   Whatever floats your boat. You just have to make sure all the required
+   primitive procedures are implemented and included in the output assembly. *)
+let epilogue = "";;
+
+  type counter = { get : unit -> int;
+                     incr : unit -> unit };;
+
+let rec rename_ast index expr = 
+match expr with
+| Const'(Sexpr(TaggedSexpr(name1, expr1))) -> 
+let expr_rename = rename_ast index (Const'(Sexpr(expr1))) in
+  (match expr_rename with
+  | Const'(Sexpr(expr)) -> Const'(Sexpr(TaggedSexpr(name1^(string_of_int (index.get ())), expr)))
+  | other -> Const'(Sexpr(Nil)))
+| Const'(Sexpr(TagRef(name1))) ->  Const'(Sexpr(TagRef(name1^(string_of_int (index.get ())))))
+| Const'(Sexpr(Pair(car, cdr))) -> 
+let car_rename = rename_ast index (Const'(Sexpr(car))) in
+let cdr_rename = rename_ast index (Const'(Sexpr(cdr))) in
+  (match car_rename, cdr_rename with
+  | Const'(Sexpr(s1)), Const'(Sexpr(s2)) -> Const'(Sexpr(Pair(s1, s2)))
+  | other1, other2 -> Const'(Sexpr(Nil)))
+| Set'(var,expr) -> Set'(var,(rename_ast index expr))
+| Def'(var,expr) -> Def'(var,(rename_ast index expr))
+| Seq'(expr_list) -> Seq'((List.map (rename_ast index) expr_list))
+| Or'(expr_list) -> Or'((List.map (rename_ast index) expr_list))
+| If'(expr1,expr2,expr3) -> If'((rename_ast index expr1),(rename_ast index expr2),(rename_ast index expr3))
+| BoxSet'(var,expr) -> BoxSet'(var,(rename_ast index expr))
+| LambdaSimple'(string_list,body) -> LambdaSimple'(string_list,(rename_ast index body))
+| LambdaOpt'(string_list,string,body) -> LambdaOpt'(string_list,string,(rename_ast index body))
+| Applic'(expr,expr_list) -> Applic'((rename_ast index expr),(List.map (rename_ast index) expr_list))
+| ApplicTP'(expr,expr_list) -> ApplicTP'((rename_ast index expr),(List.map (rename_ast index) expr_list))
+| other -> other;;
+
+let index =
+      let n = ref (-0) in
+      { get = (fun () -> !n);
+        incr = (fun () -> n:= !n +1) } ;;
+
+exception X_missing_input_file;;
+
+try
+  let infile = Sys.argv.(1) in
+  let code =  
+  (file_to_string "stdlib.scm") ^ 
+  (file_to_string infile) in
+  let asts = string_to_asts code in
+  let asts = List.map (fun ast -> index.incr (); rename_ast index ast) asts in
+  let consts_tbl = Code_Gen.make_consts_tbl asts in
+  let fvars_tbl = Code_Gen.make_fvars_tbl asts in
+  let generate = Code_Gen.generate consts_tbl fvars_tbl in
+  let code_fragment = String.concat "\n\n"
+                        (List.map
+                           (fun ast -> (generate ast) ^ "\n\tcall write_sob_if_not_void")
+                           asts) in
+  (* clean_exit contains instructions to clean the dummy stack
+     and return exit code 0 ("all's well") from procedure main. *)
+  let clean_exit ="\n\n\tmov rax, 0\n\tadd rsp, 4*8\n\tpop rbp\n\tret\n\n" in
+  let provided_primitives = file_to_string "prims.s" in
+
+  print_string ((make_prologue consts_tbl fvars_tbl)
+    ^
+                  code_fragment ^ clean_exit ^
+                    provided_primitives ^ "\n" ^ epilogue)
+
+with Invalid_argument(x) -> raise X_missing_input_file;;
diff --git a/compiler.s b/compiler.s
index ee63dfb..d88c1e7 100644
--- a/compiler.s
+++ b/compiler.s
@@ -1,642 +1,660 @@
-%define T_UNDEFINED 0
-%define T_VOID 1
-%define T_NIL 2
-%define T_INTEGER 3
-%define T_FLOAT 4
-%define T_BOOL 5
-%define T_CHAR 6
-%define T_STRING 7
-%define T_SYMBOL 8
-%define T_CLOSURE 9
-%define T_PAIR 10
-	
-%define CHAR_NUL 0
-%define CHAR_TAB 9
-%define CHAR_NEWLINE 10
-%define CHAR_PAGE 12
-%define CHAR_RETURN 13
-%define CHAR_SPACE 32
-%define CHAR_DOUBLEQUOTE 34
-%define CHAR_BACKSLASH 92
-	
-%define TYPE_SIZE 1
-%define WORD_SIZE 8
-	
-%define KB(n) n*1024
-%define MB(n) 1024*KB(n)
-%define GB(n) 1024*MB(n)
-
-
-%macro SKIP_TYPE_TAG 2
-	mov %1, qword [%2+TYPE_SIZE]	
-%endmacro	
-
-%define INT_VAL SKIP_TYPE_TAG
-
-%macro CHAR_VAL 2
-	movzx %1, byte [%2+TYPE_SIZE]
-%endmacro
-
-%define FLOAT_VAL SKIP_TYPE_TAG
-
-%define STRING_LENGTH SKIP_TYPE_TAG
-
-%define SYMBOL_VAL SKIP_TYPE_TAG
-
-%macro STRING_ELEMENTS 2
-	lea %1, [%2+TYPE_SIZE+WORD_SIZE]
-%endmacro
-
-%define CAR SKIP_TYPE_TAG
-
-%macro CDR 2
-	mov %1, qword [%2+TYPE_SIZE+WORD_SIZE]
-%endmacro
-
-%define CLOSURE_ENV CAR
-
-%define CLOSURE_CODE CDR
-
-%define PVAR(n) qword [rbp+(4+n)*WORD_SIZE]
-	
-%define SOB_UNDEFINED T_UNDEFINED
-%define SOB_NIL T_NIL
-%define SOB_VOID T_VOID
-%define SOB_FALSE word T_BOOL
-%define SOB_TRUE word (1 << TYPE_SIZE | T_BOOL)
-
-; returns %2 allocated bytes in register %1
-; Supports using with %1 = %2
-%macro MALLOC 2
-	add qword [malloc_pointer], %2
-	push %2
-	mov %1, qword [malloc_pointer]
-	sub %1, [rsp]
-	add rsp, 8
-%endmacro
-	
-; Creates a short SOB with the
-; value %2
-; Returns the result in register %1
-%macro MAKE_CHAR_VALUE 2
-	MALLOC %1, 1+TYPE_SIZE
-	mov byte [%1], T_CHAR
-	mov byte [%1+TYPE_SIZE], %2
-%endmacro
-
-; Creates a long SOB with the
-; value %2 and type %3.
-; Returns the result in register %1
-%macro MAKE_LONG_VALUE 3
-	MALLOC %1, TYPE_SIZE+WORD_SIZE
-	mov byte [%1], %3
-	mov qword [%1+TYPE_SIZE], %2
-%endmacro
-
-%define MAKE_INT(r,val) MAKE_LONG_VALUE r, val, T_INTEGER
-%define MAKE_FLOAT(r,val) MAKE_LONG_VALUE r, val, T_FLOAT
-%define MAKE_CHAR(r,val) MAKE_CHAR_VALUE r, val
-
-; Create a string of length %2
-; from char %3.
-; Stores result in register %1
-%macro MAKE_STRING 3
-	lea %1, [%2+WORD_SIZE+TYPE_SIZE]
-	MALLOC %1, %1
-	mov byte [%1], T_STRING
-	mov qword [%1+TYPE_SIZE], %2
-	push rcx
-	add %1,WORD_SIZE+TYPE_SIZE
-	mov rcx, %2
-	cmp rcx, 0
-%%str_loop:
-	jz %%str_loop_end
-	dec rcx
-	mov byte [%1+rcx], %3
-	jmp %%str_loop
-%%str_loop_end:
-	pop rcx
-	sub %1, WORD_SIZE+TYPE_SIZE
-%endmacro
-
-;;; Creates a SOB with tag %2 
-;;; from two pointers %3 and %4
-;;; Stores result in register %1
-%macro MAKE_TWO_WORDS 4 
-        MALLOC %1, TYPE_SIZE+WORD_SIZE*2
-        mov byte [%1], %2
-        mov qword [%1+TYPE_SIZE], %3
-        mov qword [%1+TYPE_SIZE+WORD_SIZE], %4
-%endmacro
-
-%macro MAKE_WORDS_LIT 3
-	db %1
-        dq %2
-        dq %3
-%endmacro
-
-%define MAKE_PAIR(r, car, cdr) \
-        MAKE_TWO_WORDS r, T_PAIR, car, cdr
-
-%define MAKE_LITERAL_PAIR(car, cdr) \
-        MAKE_WORDS_LIT T_PAIR, car, cdr
-
-%define MAKE_CLOSURE(r, env, body) \
-        MAKE_TWO_WORDS r, T_CLOSURE, env, body
-
-	
-extern printf, malloc
-global write_sob, write_sob_if_not_void
-
-	
-write_sob_undefined:
-	push rbp
-	mov rbp, rsp
-
-	mov rax, 0
-	mov rdi, .undefined
-	call printf
-
-	leave
-	ret
-
-section .data
-.undefined:
-	db "#<undefined>", 0
-
-write_sob_integer:
-	push rbp
-	mov rbp, rsp
-
-	INT_VAL rsi, rsi
-	mov rdi, .int_format_string
-	mov rax, 0
-	call printf
-
-	leave
-	ret
-
-section .data
-.int_format_string:
-	db "%ld", 0
-
-write_sob_float:
-	push rbp
-	mov rbp, rsp
-
-	FLOAT_VAL rsi, rsi
-	movq xmm0, rsi
-	mov rdi, .float_format_string
-	mov rax, 1
-
-	mov rsi, rsp
-	and rsp, -16
-	call printf
-	mov rsp, rsi
-
-	leave
-	ret
-	
-section .data
-.float_format_string:
-	db "%f", 0		
-
-write_sob_char:
-	push rbp
-	mov rbp, rsp
-
-	CHAR_VAL rsi, rsi
-
-	cmp rsi, CHAR_NUL
-	je .Lnul
-
-	cmp rsi, CHAR_TAB
-	je .Ltab
-
-	cmp rsi, CHAR_NEWLINE
-	je .Lnewline
-
-	cmp rsi, CHAR_PAGE
-	je .Lpage
-
-	cmp rsi, CHAR_RETURN
-	je .Lreturn
-
-	cmp rsi, CHAR_SPACE
-	je .Lspace
-	jg .Lregular
-
-	mov rdi, .special
-	jmp .done	
-
-.Lnul:
-	mov rdi, .nul
-	jmp .done
-
-.Ltab:
-	mov rdi, .tab
-	jmp .done
-
-.Lnewline:
-	mov rdi, .newline
-	jmp .done
-
-.Lpage:
-	mov rdi, .page
-	jmp .done
-
-.Lreturn:
-	mov rdi, .return
-	jmp .done
-
-.Lspace:
-	mov rdi, .space
-	jmp .done
-
-.Lregular:
-	mov rdi, .regular
-	jmp .done
-
-.done:
-	mov rax, 0
-	call printf
-
-	leave
-	ret
-
-section .data
-.space:
-	db "#\space", 0
-.newline:
-	db "#\newline", 0
-.return:
-	db "#\return", 0
-.tab:
-	db "#\tab", 0
-.page:
-	db "#\page", 0
-.nul:
-	db "#\nul", 0
-.special:
-	db "#\x%02x", 0
-.regular:
-	db "#\%c", 0
-
-write_sob_void:
-	push rbp
-	mov rbp, rsp
-
-	mov rax, 0
-	mov rdi, .void
-	call printf
-
-	leave
-	ret
-
-section .data
-.void:
-	db "#<void>", 0
-	
-write_sob_bool:
-	push rbp
-	mov rbp, rsp
-
-	cmp word [rsi], SOB_FALSE
-	je .sobFalse
-	
-	mov rdi, .true
-	jmp .continue
-
-.sobFalse:
-	mov rdi, .false
-
-.continue:
-	mov rax, 0
-	call printf	
-
-	leave
-	ret
-
-section .data			
-.false:
-	db "#f", 0
-.true:
-	db "#t", 0
-
-write_sob_nil:
-	push rbp
-	mov rbp, rsp
-
-	mov rax, 0
-	mov rdi, .nil
-	call printf
-
-	leave
-	ret
-
-section .data
-.nil:
-	db "()", 0
-
-write_sob_string:
-	push rbp
-	mov rbp, rsp
-
-	push rsi
-
-	mov rax, 0
-	mov rdi, .double_quote
-	call printf
-	
-	pop rsi
-
-	STRING_LENGTH rcx, rsi
-	STRING_ELEMENTS rax, rsi
-
-.loop:
-	cmp rcx, 0
-	je .done
-	mov bl, byte [rax]
-	and rbx, 0xff
-
-	cmp rbx, CHAR_TAB
-	je .ch_tab
-	cmp rbx, CHAR_NEWLINE
-	je .ch_newline
-	cmp rbx, CHAR_PAGE
-	je .ch_page
-	cmp rbx, CHAR_RETURN
-	je .ch_return
-	cmp rbx, CHAR_DOUBLEQUOTE
-	je .ch_doublequote
-	cmp rbx, CHAR_BACKSLASH
-	je .ch_backslash
-	cmp rbx, CHAR_SPACE
-	jl .ch_hex
-	
-	mov rdi, .fs_simple_char
-	mov rsi, rbx
-	jmp .printf
-	
-.ch_hex:
-	mov rdi, .fs_hex_char
-	mov rsi, rbx
-	jmp .printf
-	
-.ch_tab:
-	mov rdi, .fs_tab
-	mov rsi, rbx
-	jmp .printf
-	
-.ch_page:
-	mov rdi, .fs_page
-	mov rsi, rbx
-	jmp .printf
-	
-.ch_return:
-	mov rdi, .fs_return
-	mov rsi, rbx
-	jmp .printf
-
-.ch_newline:
-	mov rdi, .fs_newline
-	mov rsi, rbx
-	jmp .printf
-
-.ch_doublequote:
-	mov rdi, .fs_doublequote
-	mov rsi, rbx
-	jmp .printf
-
-.ch_backslash:
-	mov rdi, .fs_backslash
-	mov rsi, rbx
-
-.printf:
-	push rax
-	push rcx
-	mov rax, 0
-	call printf
-	pop rcx
-	pop rax
-
-	dec rcx
-	inc rax
-	jmp .loop
-
-.done:
-	mov rax, 0
-	mov rdi, .double_quote
-	call printf
-
-	leave
-	ret
-section .data
-.double_quote:
-	db CHAR_DOUBLEQUOTE, 0
-.fs_simple_char:
-	db "%c", 0
-.fs_hex_char:
-	db "\x%02x;", 0	
-.fs_tab:
-	db "\t", 0
-.fs_page:
-	db "\f", 0
-.fs_return:
-	db "\r", 0
-.fs_newline:
-	db "\n", 0
-.fs_doublequote:
-	db CHAR_BACKSLASH, CHAR_DOUBLEQUOTE, 0
-.fs_backslash:
-	db CHAR_BACKSLASH, CHAR_BACKSLASH, 0
-
-write_sob_pair:
-	push rbp
-	mov rbp, rsp
-
-	push rsi
-	
-	mov rax, 0
-	mov rdi, .open_paren
-	call printf
-
-	mov rsi, [rsp]
-
-	CAR rsi, rsi
-	call write_sob
-
-	mov rsi, [rsp]
-	CDR rsi, rsi
-	call write_sob_pair_on_cdr
-	
-	add rsp, 1*8
-	
-	mov rdi, .close_paren
-	mov rax, 0
-	call printf
-
-	leave
-	ret
-
-section .data
-.open_paren:
-	db "(", 0
-.close_paren:
-	db ")", 0
-
-write_sob_pair_on_cdr:
-	push rbp
-	mov rbp, rsp
-
-	mov bl, byte [rsi]
-	cmp bl, T_NIL
-	je .done
-	
-	cmp bl, T_PAIR
-	je .cdrIsPair
-	
-	push rsi
-	
-	mov rax, 0
-	mov rdi, .dot
-	call printf
-	
-	pop rsi
-
-	call write_sob
-	jmp .done
-
-.cdrIsPair:
-	CDR rbx, rsi
-	push rbx
-	CAR rsi, rsi
-	push rsi
-	
-	mov rax, 0
-	mov rdi, .space
-	call printf
-	
-	pop rsi
-	call write_sob
-
-	pop rsi
-	call write_sob_pair_on_cdr
-
-	add rsp, 1*8
-
-.done:
-	leave
-	ret
-
-section .data
-.space:
-	db " ", 0
-.dot:
-	db " . ", 0
-
-write_sob_symbol:
-	push rbp
-	mov rbp, rsp
-
-	SYMBOL_VAL rsi, rsi
-	
-	STRING_LENGTH rcx, rsi
-	STRING_ELEMENTS rax, rsi
-
-	mov rdx, rcx
-
-.loop:
-	cmp rcx, 0
-	je .done
-	mov bl, byte [rax]
-	and rbx, 0xff
-
-	cmp rcx, rdx
-	jne .ch_simple
-	cmp rbx, '+'
-	je .ch_hex
-	cmp rbx, '-'
-	je .ch_hex
-	cmp rbx, 'A'
-	jl .ch_hex
-
-.ch_simple:
-	mov rdi, .fs_simple_char
-	mov rsi, rbx
-	jmp .printf
-	
-.ch_hex:
-	mov rdi, .fs_hex_char
-	mov rsi, rbx
-
-.printf:
-	push rax
-	push rcx
-	mov rax, 0
-	call printf
-	pop rcx
-	pop rax
-
-	dec rcx
-	inc rax
-	jmp .loop
-
-.done:
-	leave
-	ret
-	
-section .data
-.fs_simple_char:
-	db "%c", 0
-.fs_hex_char:
-	db "\x%02x;", 0	
-
-write_sob_closure:
-	push rbp
-	mov rbp, rsp
-
-	CLOSURE_CODE rdx, rsi
-	CLOSURE_ENV rsi, rsi
-
-	mov rdi, .closure
-	mov rax, 0
-	call printf
-
-	leave
-	ret
-section .data
-.closure:
-	db "#<closure [env:%p, code:%p]>", 0
-
-section .text
-write_sob:
-	mov rbx, 0
-	mov bl, byte [rsi]	
-	jmp qword [.jmp_table + rbx * 8]
-
-section .data
-.jmp_table:
-	dq write_sob_undefined, write_sob_void, write_sob_nil
-	dq write_sob_integer, write_sob_float, write_sob_bool
-	dq write_sob_char, write_sob_string, write_sob_symbol
-	dq write_sob_closure, write_sob_pair
-
-section .text
-write_sob_if_not_void:
-	mov rsi, rax
-	mov bl, byte [rsi]
-	cmp bl, SOB_VOID
-	je .continue
-
-	call write_sob
-	
-	mov rax, 0
-	mov rdi, .newline
-	call printf
-	
-.continue:
-	ret
-section .data
-.newline:
-	db CHAR_NEWLINE, 0
+%define T_UNDEFINED 0
+%define T_VOID 1
+%define T_NIL 2
+%define T_INTEGER 3
+%define T_FLOAT 4
+%define T_BOOL 5
+%define T_CHAR 6
+%define T_STRING 7
+%define T_SYMBOL 8
+%define T_CLOSURE 9
+%define T_PAIR 10
+	
+%define CHAR_NUL 0
+%define CHAR_TAB 9
+%define CHAR_NEWLINE 10
+%define CHAR_PAGE 12
+%define CHAR_RETURN 13
+%define CHAR_SPACE 32
+%define CHAR_DOUBLEQUOTE 34
+%define CHAR_BACKSLASH 92
+	
+%define TYPE_SIZE 1
+%define WORD_SIZE 8
+	
+%define KB(n) n*1024
+%define MB(n) 1024*KB(n)
+%define GB(n) 1024*MB(n)
+
+%define PARAM_COUNT qword [rbp+3*WORD_SIZE]
+
+%define MAKE_NIL db T_NIL
+%define MAKE_VOID db T_VOID
+%define MAKE_BOOL(val) MAKE_LITERAL T_BOOL, db val
+%define MAKE_LITERAL_INTEGER(val) MAKE_LITERAL T_INTEGER, dq val
+%define MAKE_LITERAL_FLOAT(val) MAKE_LITERAL T_FLOAT, dq val
+%define MAKE_LITERAL_CHAR(val) MAKE_LITERAL T_CHAR, db val
+%define MAKE_LITERAL_SYMBOL(val) MAKE_LITERAL T_SYMBOL, dq val
+
+%macro MAKE_LITERAL_STRING 1
+db T_STRING
+dq (%%end_str - %%str)
+%%str:
+db %1
+%%end_str:
+%endmacro
+
+
+%macro SKIP_TYPE_TAG 2
+	mov %1, qword [%2+TYPE_SIZE]	
+%endmacro	
+
+%define INT_VAL SKIP_TYPE_TAG
+
+%macro CHAR_VAL 2
+	movzx %1, byte [%2+TYPE_SIZE]
+%endmacro
+
+%define FLOAT_VAL SKIP_TYPE_TAG
+
+%define STRING_LENGTH SKIP_TYPE_TAG
+
+%define SYMBOL_VAL SKIP_TYPE_TAG
+
+%macro STRING_ELEMENTS 2
+	lea %1, [%2+TYPE_SIZE+WORD_SIZE]
+%endmacro
+
+%define CAR SKIP_TYPE_TAG
+
+%macro CDR 2
+	mov %1, qword [%2+TYPE_SIZE+WORD_SIZE]
+%endmacro
+
+%define CLOSURE_ENV CAR
+
+%define CLOSURE_CODE CDR
+
+%define PVAR(n) qword [rbp+(4+n)*WORD_SIZE]
+	
+%define SOB_UNDEFINED T_UNDEFINED
+%define SOB_NIL T_NIL
+%define SOB_VOID T_VOID
+%define SOB_FALSE word T_BOOL
+%define SOB_TRUE word (1 << TYPE_SIZE | T_BOOL)
+
+; returns %2 allocated bytes in register %1
+; Supports using with %1 = %2
+%macro MALLOC 2
+	add qword [malloc_pointer], %2
+	push %2
+	mov %1, qword [malloc_pointer]
+	sub %1, [rsp]
+	add rsp, 8
+%endmacro
+	
+; Creates a short SOB with the
+; value %2
+; Returns the result in register %1
+%macro MAKE_CHAR_VALUE 2
+	MALLOC %1, 1+TYPE_SIZE
+	mov byte [%1], T_CHAR
+	mov byte [%1+TYPE_SIZE], %2
+%endmacro
+
+; Creates a long SOB with the
+; value %2 and type %3.
+; Returns the result in register %1
+%macro MAKE_LONG_VALUE 3
+	MALLOC %1, TYPE_SIZE+WORD_SIZE
+	mov byte [%1], %3
+	mov qword [%1+TYPE_SIZE], %2
+%endmacro
+
+%define MAKE_INT(r,val) MAKE_LONG_VALUE r, val, T_INTEGER
+%define MAKE_FLOAT(r,val) MAKE_LONG_VALUE r, val, T_FLOAT
+%define MAKE_CHAR(r,val) MAKE_CHAR_VALUE r, val
+
+; Create a string of length %2
+; from char %3.
+; Stores result in register %1
+%macro MAKE_STRING 3
+	lea %1, [%2+WORD_SIZE+TYPE_SIZE]
+	MALLOC %1, %1
+	mov byte [%1], T_STRING
+	mov qword [%1+TYPE_SIZE], %2
+	push rcx
+	add %1,WORD_SIZE+TYPE_SIZE
+	mov rcx, %2
+	cmp rcx, 0
+%%str_loop:
+	jz %%str_loop_end
+	dec rcx
+	mov byte [%1+rcx], %3
+	jmp %%str_loop
+%%str_loop_end:
+	pop rcx
+	sub %1, WORD_SIZE+TYPE_SIZE
+%endmacro
+
+;;; Creates a SOB with tag %2 
+;;; from two pointers %3 and %4
+;;; Stores result in register %1
+%macro MAKE_TWO_WORDS 4 
+        MALLOC %1, TYPE_SIZE+WORD_SIZE*2
+        mov byte [%1], %2
+        mov qword [%1+TYPE_SIZE], %3
+        mov qword [%1+TYPE_SIZE+WORD_SIZE], %4
+%endmacro
+
+%macro MAKE_WORDS_LIT 3
+	db %1
+        dq %2
+        dq %3
+%endmacro
+
+%define MAKE_PAIR(r, car, cdr) \
+        MAKE_TWO_WORDS r, T_PAIR, car, cdr
+
+%define MAKE_LITERAL_PAIR(car, cdr) \
+        MAKE_WORDS_LIT T_PAIR, car, cdr
+
+%define MAKE_CLOSURE(r, env, body) \
+        MAKE_TWO_WORDS r, T_CLOSURE, env, body
+
+	
+extern printf, malloc
+global write_sob, write_sob_if_not_void
+
+	
+write_sob_undefined:
+	push rbp
+	mov rbp, rsp
+
+	mov rax, 0
+	mov rdi, .undefined
+	call printf
+
+	leave
+	ret
+
+section .data
+.undefined:
+	db "#<undefined>", 0
+
+write_sob_integer:
+	push rbp
+	mov rbp, rsp
+
+	INT_VAL rsi, rsi
+	mov rdi, .int_format_string
+	mov rax, 0
+	call printf
+
+	leave
+	ret
+
+section .data
+.int_format_string:
+	db "%ld", 0
+
+write_sob_float:
+	push rbp
+	mov rbp, rsp
+
+	FLOAT_VAL rsi, rsi
+	movq xmm0, rsi
+	mov rdi, .float_format_string
+	mov rax, 1
+
+	mov rsi, rsp
+	and rsp, -16
+	call printf
+	mov rsp, rsi
+
+	leave
+	ret
+	
+section .data
+.float_format_string:
+	db "%f", 0		
+
+write_sob_char:
+	push rbp
+	mov rbp, rsp
+
+	CHAR_VAL rsi, rsi
+
+	cmp rsi, CHAR_NUL
+	je .Lnul
+
+	cmp rsi, CHAR_TAB
+	je .Ltab
+
+	cmp rsi, CHAR_NEWLINE
+	je .Lnewline
+
+	cmp rsi, CHAR_PAGE
+	je .Lpage
+
+	cmp rsi, CHAR_RETURN
+	je .Lreturn
+
+	cmp rsi, CHAR_SPACE
+	je .Lspace
+	jg .Lregular
+
+	mov rdi, .special
+	jmp .done	
+
+.Lnul:
+	mov rdi, .nul
+	jmp .done
+
+.Ltab:
+	mov rdi, .tab
+	jmp .done
+
+.Lnewline:
+	mov rdi, .newline
+	jmp .done
+
+.Lpage:
+	mov rdi, .page
+	jmp .done
+
+.Lreturn:
+	mov rdi, .return
+	jmp .done
+
+.Lspace:
+	mov rdi, .space
+	jmp .done
+
+.Lregular:
+	mov rdi, .regular
+	jmp .done
+
+.done:
+	mov rax, 0
+	call printf
+
+	leave
+	ret
+
+section .data
+.space:
+	db "#\space", 0
+.newline:
+	db "#\newline", 0
+.return:
+	db "#\return", 0
+.tab:
+	db "#\tab", 0
+.page:
+	db "#\page", 0
+.nul:
+	db "#\nul", 0
+.special:
+	db "#\x%02x", 0
+.regular:
+	db "#\%c", 0
+
+write_sob_void:
+	push rbp
+	mov rbp, rsp
+
+	mov rax, 0
+	mov rdi, .void
+	call printf
+
+	leave
+	ret
+
+section .data
+.void:
+	db "#<void>", 0
+	
+write_sob_bool:
+	push rbp
+	mov rbp, rsp
+
+	cmp word [rsi], SOB_FALSE
+	je .sobFalse
+	
+	mov rdi, .true
+	jmp .continue
+
+.sobFalse:
+	mov rdi, .false
+
+.continue:
+	mov rax, 0
+	call printf	
+
+	leave
+	ret
+
+section .data			
+.false:
+	db "#f", 0
+.true:
+	db "#t", 0
+
+write_sob_nil:
+	push rbp
+	mov rbp, rsp
+
+	mov rax, 0
+	mov rdi, .nil
+	call printf
+
+	leave
+	ret
+
+section .data
+.nil:
+	db "()", 0
+
+write_sob_string:
+	push rbp
+	mov rbp, rsp
+
+	push rsi
+
+	mov rax, 0
+	mov rdi, .double_quote
+	call printf
+	
+	pop rsi
+
+	STRING_LENGTH rcx, rsi
+	STRING_ELEMENTS rax, rsi
+
+.loop:
+	cmp rcx, 0
+	je .done
+	mov bl, byte [rax]
+	and rbx, 0xff
+
+	cmp rbx, CHAR_TAB
+	je .ch_tab
+	cmp rbx, CHAR_NEWLINE
+	je .ch_newline
+	cmp rbx, CHAR_PAGE
+	je .ch_page
+	cmp rbx, CHAR_RETURN
+	je .ch_return
+	cmp rbx, CHAR_DOUBLEQUOTE
+	je .ch_doublequote
+	cmp rbx, CHAR_BACKSLASH
+	je .ch_backslash
+	cmp rbx, CHAR_SPACE
+	jl .ch_hex
+	
+	mov rdi, .fs_simple_char
+	mov rsi, rbx
+	jmp .printf
+	
+.ch_hex:
+	mov rdi, .fs_hex_char
+	mov rsi, rbx
+	jmp .printf
+	
+.ch_tab:
+	mov rdi, .fs_tab
+	mov rsi, rbx
+	jmp .printf
+	
+.ch_page:
+	mov rdi, .fs_page
+	mov rsi, rbx
+	jmp .printf
+	
+.ch_return:
+	mov rdi, .fs_return
+	mov rsi, rbx
+	jmp .printf
+
+.ch_newline:
+	mov rdi, .fs_newline
+	mov rsi, rbx
+	jmp .printf
+
+.ch_doublequote:
+	mov rdi, .fs_doublequote
+	mov rsi, rbx
+	jmp .printf
+
+.ch_backslash:
+	mov rdi, .fs_backslash
+	mov rsi, rbx
+
+.printf:
+	push rax
+	push rcx
+	mov rax, 0
+	call printf
+	pop rcx
+	pop rax
+
+	dec rcx
+	inc rax
+	jmp .loop
+
+.done:
+	mov rax, 0
+	mov rdi, .double_quote
+	call printf
+
+	leave
+	ret
+section .data
+.double_quote:
+	db CHAR_DOUBLEQUOTE, 0
+.fs_simple_char:
+	db "%c", 0
+.fs_hex_char:
+	db "\x%02x;", 0	
+.fs_tab:
+	db "\t", 0
+.fs_page:
+	db "\f", 0
+.fs_return:
+	db "\r", 0
+.fs_newline:
+	db "\n", 0
+.fs_doublequote:
+	db CHAR_BACKSLASH, CHAR_DOUBLEQUOTE, 0
+.fs_backslash:
+	db CHAR_BACKSLASH, CHAR_BACKSLASH, 0
+
+write_sob_pair:
+	push rbp
+	mov rbp, rsp
+
+	push rsi
+	
+	mov rax, 0
+	mov rdi, .open_paren
+	call printf
+
+	mov rsi, [rsp]
+
+	CAR rsi, rsi
+	call write_sob
+
+	mov rsi, [rsp]
+	CDR rsi, rsi
+	call write_sob_pair_on_cdr
+	
+	add rsp, 1*8
+	
+	mov rdi, .close_paren
+	mov rax, 0
+	call printf
+
+	leave
+	ret
+
+section .data
+.open_paren:
+	db "(", 0
+.close_paren:
+	db ")", 0
+
+write_sob_pair_on_cdr:
+	push rbp
+	mov rbp, rsp
+
+	mov bl, byte [rsi]
+	cmp bl, T_NIL
+	je .done
+	
+	cmp bl, T_PAIR
+	je .cdrIsPair
+	
+	push rsi
+	
+	mov rax, 0
+	mov rdi, .dot
+	call printf
+	
+	pop rsi
+
+	call write_sob
+	jmp .done
+
+.cdrIsPair:
+	CDR rbx, rsi
+	push rbx
+	CAR rsi, rsi
+	push rsi
+	
+	mov rax, 0
+	mov rdi, .space
+	call printf
+	
+	pop rsi
+	call write_sob
+
+	pop rsi
+	call write_sob_pair_on_cdr
+
+	add rsp, 1*8
+
+.done:
+	leave
+	ret
+
+section .data
+.space:
+	db " ", 0
+.dot:
+	db " . ", 0
+
+write_sob_symbol:
+	push rbp
+	mov rbp, rsp
+
+	SYMBOL_VAL rsi, rsi
+	
+	STRING_LENGTH rcx, rsi
+	STRING_ELEMENTS rax, rsi
+
+	mov rdx, rcx
+
+.loop:
+	cmp rcx, 0
+	je .done
+	mov bl, byte [rax]
+	and rbx, 0xff
+
+	cmp rcx, rdx
+	jne .ch_simple
+	cmp rbx, '+'
+	je .ch_hex
+	cmp rbx, '-'
+	je .ch_hex
+	cmp rbx, 'A'
+	jl .ch_hex
+
+.ch_simple:
+	mov rdi, .fs_simple_char
+	mov rsi, rbx
+	jmp .printf
+	
+.ch_hex:
+	mov rdi, .fs_hex_char
+	mov rsi, rbx
+
+.printf:
+	push rax
+	push rcx
+	mov rax, 0
+	call printf
+	pop rcx
+	pop rax
+
+	dec rcx
+	inc rax
+	jmp .loop
+
+.done:
+	leave
+	ret
+	
+section .data
+.fs_simple_char:
+	db "%c", 0
+.fs_hex_char:
+	db "\x%02x;", 0	
+
+write_sob_closure:
+	push rbp
+	mov rbp, rsp
+
+	CLOSURE_CODE rdx, rsi
+	CLOSURE_ENV rsi, rsi
+
+	mov rdi, .closure
+	mov rax, 0
+	call printf
+
+	leave
+	ret
+section .data
+.closure:
+	db "#<closure [env:%p, code:%p]>", 0
+
+section .text
+write_sob:
+	mov rbx, 0
+	mov bl, byte [rsi]	
+	jmp qword [.jmp_table + rbx * 8]
+
+section .data
+.jmp_table:
+	dq write_sob_undefined, write_sob_void, write_sob_nil
+	dq write_sob_integer, write_sob_float, write_sob_bool
+	dq write_sob_char, write_sob_string, write_sob_symbol
+	dq write_sob_closure, write_sob_pair
+
+section .text
+write_sob_if_not_void:
+	mov rsi, rax
+	mov bl, byte [rsi]
+	cmp bl, SOB_VOID
+	je .continue
+
+	call write_sob
+	
+	mov rax, 0
+	mov rdi, .newline
+	call printf
+	
+.continue:
+	ret
+section .data
+.newline:
+	db CHAR_NEWLINE, 0
diff --git a/prims.s b/prims.s
index 159b4eb..13ebe57 100644
--- a/prims.s
+++ b/prims.s
@@ -817,3 +817,192 @@ bin_equ:
     leave
     ret
 
+
+car_label:
+push rbp
+mov rbp, rsp
+
+    mov r8, PVAR(0)
+    mov rax, qword [r8 + 1]
+
+leave
+ret
+
+cdr_label:
+push rbp
+mov rbp, rsp
+
+    mov r8, PVAR(0)
+    mov rax, qword [r8 + 9]
+
+leave
+ret
+
+cons_label:
+push rbp
+mov rbp, rsp
+
+  mov r8, PVAR(0)
+  mov r9, PVAR(1)
+  MAKE_PAIR(rax,r8,r9)
+leave
+ret
+
+
+set_car_label:
+push rbp
+mov rbp, rsp
+
+    mov r10, PVAR(1) ;set to
+    mov r8, PVAR(0) ; pointer to pair
+    mov rax, r8
+    mov qword [rax + 1], r10 ; set car to r10
+    mov rax, SOB_VOID_ADDRESS
+
+leave
+ret
+
+set_cdr_label:
+push rbp
+mov rbp, rsp
+
+    mov r10, PVAR(1) ;set to
+    mov r8, PVAR(0) ; pointer to pair
+    mov rax, r8
+    mov qword [rax + 9], r10 ; set car to r10
+    mov rax, SOB_VOID_ADDRESS
+
+leave
+ret
+
+apply_label:
+push rbp
+mov rbp, rsp
+
+mov qword [rbp - 8], SOB_NIL_ADDRESS
+mov r8, PARAM_COUNT ;r8=n
+add r8, 3
+shl r8, 3
+add r8, rbp
+mov r9, qword [r8] ;r9->list
+mov r10, r9 ;r10->list
+mov r11, 0 ;r11=list length
+cmp r9, SOB_NIL_ADDRESS
+je .skip_list
+
+.len:
+cmp r9, SOB_NIL_ADDRESS
+je .prepare_extract
+CDR r9, r9
+inc r11
+jmp .len
+
+
+.prepare_extract:
+mov r9, r10
+mov rcx, r11 
+mov r8, r11 ;r8=len
+mov r10, 1 ;i=1
+
+.extract_list:
+mov rax, qword [r9+TYPE_SIZE] ;rax=car
+mov r13, r8 ;r13=len
+add r13, r10 ;r13=len+i
+shl r13, 3 ;r8=8*(len+i)
+mov r12, rbp
+sub r12, r13 ;r12=rbp-8*(len+i)
+mov qword [r12], rax
+mov r9, qword [r9+TYPE_SIZE+8]
+dec r10
+loop .extract_list
+
+.skip_list:
+mov rcx, PARAM_COUNT 
+sub rcx, 2 ;rcx=n-2
+mov r8, 2 ;i=2
+
+.copy_params:
+mov r9, rcx ;r9=n-2
+add r9, 4 ;r9=(n-2)+4=n+2
+shl r9, 3 ;r9=8*(n+2)
+mov rax, rbp
+add rax, r9 ;rax=rbp + 8*(n+2)
+mov r12, qword [rax] ;r12=[rbp + 8*(n+2)]
+mov r10, r11
+add r10, r8
+shl r10, 3 ;r10= 8*(r11+r8)
+mov r14, rbp
+sub r14, r10
+mov qword [r14], r12 ; [rbp + 8*(n+2)] -> [rbp - (8 * (len + i))]
+inc r8 ;i++
+loop .copy_params
+
+mov rax, r11 ;rax=len
+add rax, PARAM_COUNT ;rax=len+n
+sub rax, 2 ;rax = (len+n)-2 = new params len
+mov r10, rax
+add r10, 2
+shl r10, 3
+mov r14, rbp
+sub r14, r10
+mov qword [r14], rax
+
+mov r8, qword [rbp + 8 * 4] ;r8=proc closure
+CLOSURE_ENV r10, r8 ;r10=proc env
+mov r13, rax
+add r13, 3
+shl r13, 3
+mov r14, rbp
+sub r14, r13
+mov qword [r14], r10 ;push env
+mov r9, qword [rbp + 8] ;r9=ret
+mov r13, rax
+add r13, 4
+shl r13, 3
+mov r14, rbp
+sub r14, r13
+mov qword [r14], r9 ;push ret
+
+;ApplicTP code
+mov r15, r8
+mov r8, qword [rbp]
+mov rax, PARAM_COUNT
+mov r12, PARAM_COUNT
+mov rdi, r11
+add rax, 5 ; rax = n (old) +5
+mov r14, r12
+add r14, rdi
+sub r14, 2
+mov rcx, r14 ;rcx=m
+add rcx, 5 ;rcx=m+5
+mov r14, rax
+mov r13, 1 ; running index
+.override_old_frame:
+    dec rax
+    mov r9, rbp
+    mov r10, r13
+    shl r10, 3
+    sub r9, r10 ; r9 = rbp - 8*i
+    mov r11, qword [r9]
+    mov qword [rbp+8*rax], r11
+    inc r13
+    loop .override_old_frame
+
+mov r14, r12
+add r14, rdi
+sub r14, 2
+mov rcx, r14 ;rcx=m
+sub rcx, r12 ; rcx = m-n
+shl rcx, 3 ; rcx = 8(m-n)
+mov r14, rbp
+sub r14, rcx ; rax = rbp - 8(m-n)
+mov rsp, r14
+
+mov rax, r15
+CLOSURE_CODE r10, rax
+add rsp, 8
+mov rbp, r8
+jmp r10
+
+leave
+ret
\ No newline at end of file
diff --git a/reader.ml b/reader.ml
index c4fd6b2..77c6fa2 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,5 +1,5 @@
-
 #use "pc.ml";;
+open PC;;
 
 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
@@ -33,7 +33,8 @@ let rec sexpr_eq s1 s2 =
   | TagRef(name1), TagRef(name2) -> name1 = name2
   | _ -> false;;
   
-module Reader: sig
+module Reader 
+: sig
   val read_sexpr : string -> sexpr
   val read_sexprs : string -> sexpr list
 end
@@ -44,9 +45,367 @@ let normalize_scheme_symbol str =
 	(fun ch -> (ch = (lowercase_ascii ch)))
 	s) then str
   else Printf.sprintf "|%s|" str;;
+  
+(*abstract parsers*)
+(* abstract parser that skips nt_right and nt_left results from left and right of nt *)
+let make_paired nt_left nt_right nt =
+  let nt = caten nt_left nt in
+  let nt = pack nt (function (_, e) -> e) in
+  let nt = caten nt nt_right in
+  let nt = pack nt (function (e, _) -> e) in
+  nt;;
 
-let read_sexpr string = raise X_not_yet_implemented ;;
+(* 3.2.1 Whitespaces *)
+let nt_whitespace = const (fun ch -> ch <= ' ');;
+(* parser that skips whitesapes from left and right of nt *)
+let make_spaced nt = make_paired (star nt_whitespace) (star nt_whitespace) nt;;
+
+(* 3.2.2 Line comments *)
+let nt_comment_line = 
+    let nt_semicolon = char ';' in
+    let nt_eol = char (char_of_int 10) in
+    let nt_all_but_eol = diff nt_any nt_eol in
+    let nt_end_of_comment = disj nt_eol (pack nt_end_of_input (fun (dummy) -> 'd')) in
+    let nt = caten nt_semicolon (star nt_all_but_eol) in
+    let nt = caten nt nt_end_of_comment in
+    let nt = pack nt (fun e -> Nil) in
+    make_spaced nt;;
+    
+
+(*3.3.1 Boolean*)
+let nt_boolean =
+    let nt_hashtag = char '#' in
+    let nt_f = word_ci "f" in
+    let nt_t = word_ci "t" in
+    let nt_false = pack nt_f (fun f -> false) in
+    let nt_true = pack nt_t (fun t -> true) in
+    let nt = disj nt_false nt_true in
+    let nt = caten nt_hashtag nt in
+    (* let nt = pack nt (function (_, false) ->                     |TaggedSexpr(some_name, some_sexpr) -> if (name == some_name) && sexpr_eq some_sexpr sexpr
+(Bool false)) in  *)
+    let nt = pack nt (function (_0x, e) -> (Bool e)) in
+nt;;
+
+(*3.3.3 Symbol*)
+let digit = range '0' '9';;
+
+let nt_symbol =
+    let lowercase_letters = range 'a' 'z' in
+    let uppercase_letters = range 'A' 'Z' in
+    let punctuation = disj_list [char ':';char '!'; char '$'; char '^'; char '*'; char '-'; char '_'; char '='; char '+'; char '<'; char '>'; char '/'; char '?'] in    
+    let norm_uppercase = pack uppercase_letters lowercase_ascii in
+    let nt = disj_list [lowercase_letters; norm_uppercase; punctuation; digit] in
+    let nt = plus nt in
+    let nt = pack nt (fun e -> let str = list_to_string e in Symbol(str)) in
+    nt;;
+
+(*3.3.2 Number*)
+let not_digit = const (fun ch -> ch < '0' || ch > '9');;
+
+(*int*)
+let nt_int = 
+    let nt_body = pack (not_followed_by (plus digit) (char '.')) (function e -> int_of_string ((list_to_string e))) in
+    let nt_plus_op = char '+' in
+    let nt_minus_op = char '-' in
+    let nt_op = disj nt_minus_op nt_plus_op in
+    let nt_signed = pack (caten nt_op nt_body) 
+    (function (op,num) -> if (op = '-') then (-1)*(num) else num) in
+    let nt = disj nt_signed nt_body in
+    nt;;
+
+
+let nt_int_packed = 
+    let nt = not_followed_by nt_int nt_symbol in
+    pack nt (fun e -> Int(e));;
+ 
+(*float*)
+let nt_float =
+    let nt_dot = char '.' in
+    let nt_form = caten (plus digit) (caten nt_dot (plus digit)) in
+    let nt_body = pack nt_form 
+    (function (a,(b, c)) -> float_of_string ((list_to_string a) ^ "." ^ (list_to_string c))) in
+    let nt_plus_op = char '+' in
+    let nt_minus_op = char '-' in
+    let nt_op = disj nt_minus_op nt_plus_op in
+    let nt_signed = pack (caten nt_op nt_body) 
+    (function (op,num) -> if (op = '-') then (-1.0)*.(num) else num) in
+    let nt = disj nt_signed nt_body in
+    nt;;
+    (*number*)
+
+let nt_float_packed = 
+    let nt_symbols_not_e = diff nt_symbol (word_ci "e") in
+    let nt = not_followed_by nt_float nt_symbols_not_e in
+    pack nt (fun e -> Float(e));;
+    
+    (*number*)
+
+(*4.1 Scientific notation*)
+let nt_scientific_notation = 
+    let nt_int_to_float = pack nt_int (fun e -> float_of_int e) in
+    let nt = disj nt_int_to_float nt_float in
+    let nt_e = word_ci "e" in
+    let nt = caten nt (caten nt_e nt_int_to_float) in
+    (* let nt = not_followed_by nt nt_symbol in *)
+    let nt = pack nt (fun (num, (e, exp)) -> let n = num *. (10. ** exp) in Float(n)) in
+    nt;;
+
+
+let make_nt_digit ch_from ch_to displacement =
+    let nt = const (fun ch -> ch_from <= ch && ch <= ch_to) in
+    let nt = pack nt (let delta = (Char.code ch_from) - displacement in
+		      fun ch -> (Char.code ch) - delta) in
+    nt;;
+
+let nt_radix_cal radix =
+  let nt = disj (make_nt_digit '0' '9' 0)
+		(make_nt_digit 'a' 'z' 10) in
+  let nt = disj nt (make_nt_digit 'A' 'Z' 10) in
+  let nt = plus nt in
+  let nt = pack nt (fun digits ->
+		    List.fold_left (fun a b -> radix * a + b) 0 digits) in
+  nt;;
+
+let nt_radix_cal_float radix =
+  let nt = disj (make_nt_digit '0' '9' 0)
+		(make_nt_digit 'a' 'z' 10) in
+  let nt = disj nt (make_nt_digit 'A' 'Z' 10) in
+  let nt = pack nt (fun e -> float_of_int e) in
+  let nt = plus nt in
+  (* let nt = pack nt (fun digits -> (1./.(float_of_int radix))) in   *)
+  let nt = pack nt (fun digits -> List.fold_right (fun a b -> (1./.(float_of_int radix)) *. (b +. a)) digits 0.) in  
+  nt;;
+
+let nt_radix_range = disj_list [digit; range 'a' 'z'; range 'A' 'Z'] ;;
+
+let nt_radix_identifier = 
+    let nt_hashtag = char '#' in
+    let nt_r = disj (char 'r') (char 'R') in
+    let body_until_r = caten nt_hashtag (caten nt_int nt_r) in
+
+    let nt_plus_op = char '+' in
+    let nt_minus_op = char '-' in
+    let nt_op = disj nt_minus_op nt_plus_op in
+    let nt_signed = caten body_until_r nt_op in 
+    let nt_signed = pack nt_signed (fun ((_hash, (base,r)), op) -> (op,(_hash, (base,r)))) in
+
+    let nt = disj nt_signed (pack body_until_r (fun (_hash, (base,r)) -> ('+',(_hash, (base,r))))) in
+    let nt = pack nt (fun (op, (_hash, (base,_r))) -> (op, base)) in
+    nt;;
+
+let nt_int_radix = 
+    let nt = not_followed_by (plus nt_radix_range) (char '.') in
+    let nt = caten nt_radix_identifier nt in
+    let nt = pack nt (fun ((op,base), num) -> (op, (nt_radix_cal base num))) in
+    let nt = pack nt (fun (op, (num,_)) -> if (op = '-') then (-1)*(num) else num) in
+    let nt = pack nt (fun (num) -> Int(num)) in
+    nt;;
+
+let nt_float_radix = 
+    let nt_form = caten (plus nt_radix_range) (caten (char '.') (plus nt_radix_range)) in
+    let nt = pack nt_form (fun (a, (_, b)) -> (a,b)) in
+    let nt = caten nt_radix_identifier nt in
+    let nt = pack nt (fun ((op,base), (left, right)) -> 
+    let converted_left = nt_radix_cal base left  in
+    let converted_right = nt_radix_cal_float base right in
+    (op,(converted_left, converted_right))) in
+    let nt = pack nt (fun (op,((e1,_),(e2,_))) -> 
+        let converted = (float_of_int e1) +. e2 in
+        (op, converted)) in
+    let nt = pack nt (fun (op, num) -> if (op = '-') then (-1.)*.(num) else num) in
+    let nt = pack nt (fun num -> Float(num)) in
+    nt;;
+
+let nt_number = 
+    let nt = disj_list [nt_float_radix;nt_int_radix;nt_scientific_notation;nt_float_packed; nt_int_packed] in
+    let nt = pack nt (function e -> Number(e)) in
+    nt;;
+
+(*3.3.4 String*)
+let nt_string = 
+    let string_literal_char = diff nt_any (disj (char (char_of_int 34)) (char (char_of_int 92))) in
+    let string_meta_char = disj_list [
+        pack (word "\\\\") (fun e -> char_of_int 92);
+        pack (word "\\\"") (fun e -> char_of_int 34);
+        pack (word "\\t") (fun e -> char_of_int 9);
+        pack (word "\\f") (fun e -> char_of_int 12);
+        pack (word "\\n") (fun e -> char_of_int 10);
+        pack (word "\\r") (fun e -> char_of_int 13)
+        ] in
+    let nt_body = disj string_literal_char string_meta_char in
+    let nt_double_quote = char (char_of_int (34)) in
+    let nt = caten nt_double_quote (caten (star nt_body) nt_double_quote) in
+    let nt = pack nt (fun (_, (e, _)) -> String(list_to_string e)) in
+    nt;;
+
+(*3.3.5 Char*)
+let nt_char =
+    let char_prefix = caten (char '#') (char '\\') in
+    let visible_simple_char = const (fun ch -> (int_of_char ch) > 32) in
+    let named_char = disj_list [
+        pack (word_ci "nul") (fun e -> char_of_int 0);
+        pack (word_ci "newline") (fun e -> char_of_int 10);
+        pack (word_ci "return") (fun e -> char_of_int 13);
+        pack (word_ci "tab") (fun e -> char_of_int 9);
+        pack (word_ci "page") (fun e -> char_of_int 12);
+        pack (word_ci "space") (fun e -> char_of_int 32)
+        ] in
+    let nt = disj named_char visible_simple_char in
+    let nt = pack (caten char_prefix nt) (fun (_, e) -> Char(e)) in
+    nt;;
+
+let nt_teg_ref_identifier= 
+    let prefix = word "#{" in
+    let postfix = word "}" in
+    let symbol_name = pack nt_symbol (
+        function e -> match e with
+        | Symbol(name) -> name
+        | other_sexpr -> raise X_no_match ) in
+    let nt = caten prefix (caten (symbol_name) postfix) in
+    let nt = pack nt (fun (_, (name, _)) -> name) in
+    nt;;
+
+let rec fun1 acc_list original_list = 
+    match original_list with
+    |Pair(sexpr1, sexpr2) -> let a = (List.append (fun1 acc_list sexpr1) acc_list) in let b = (List.append (fun1 acc_list sexpr2) acc_list) in List.append a b
+    |TaggedSexpr(name, sexpr) -> List.append [TaggedSexpr(name, sexpr)] acc_list
+    |other -> acc_list
+
+let fun2 lst = 
+    let rec same_tag_exists_in_list compare_name tag_list = match tag_list with
+        | TaggedSexpr(name, sexpr) :: rest_of_list -> if name = compare_name then true else same_tag_exists_in_list compare_name rest_of_list 
+        | other -> false in
+
+    let rec choose_tag tag_list =
+        match tag_list with
+        | TaggedSexpr(name, sexpr) :: rest_of_list -> if (same_tag_exists_in_list name rest_of_list) then false else choose_tag rest_of_list
+        | other -> true in
+
+        choose_tag lst;;
+
+
+let check_if_valid_list paired_list =
+let lst = [] in
+let tag_list = fun1 lst paired_list in
+let is_valid = fun2 tag_list in
+         if is_valid then paired_list else raise X_this_should_not_happen;;
+(* sexp *)
+
+let rec nt_sexpr str = 
+    let sexpr_disj = disj_list [
+            nt_boolean;
+            nt_char;
+            nt_number;
+            nt_string;
+            nt_symbol;
+            nt_nil;
+            nt_list;
+            nt_dotted_list;
+            nt_quote;
+            nt_quasi_quote;
+            nt_unquote;
+            nt_unquote_and_splice;
+            nt_tagged_sexpr;
+            nt_tag_ref
+           ] in
+    (make_spaced_or_commented sexpr_disj) str
+    and nt_list s = 
+        let prefix = char '(' in
+        let postfix = char ')' in
+        let body = star nt_sexpr in
+        let nt = caten prefix (caten body postfix) in
+        let nt = pack nt (
+            function (_,(e,_)) -> match e with
+            |[] -> Nil
+            |lst -> List.fold_right (fun sexpr1 sexpr2 -> Pair(sexpr1, sexpr2)) lst Nil
+        ) in
+        let nt = (pack nt check_if_valid_list) in
+         nt s
+    and nt_dotted_list s = 
+        let prefix = char '(' in
+        let postfix = char ')' in
+        let nt_dot = char '.' in
+        let body = caten (plus nt_sexpr) (caten nt_dot nt_sexpr) in
+        let nt = caten prefix (caten body postfix) in
+        let nt = pack nt (
+            function (_,(e,_)) -> match e with
+            |(a, (_, b)) -> List.fold_right (fun sexpr1 sexpr2 -> Pair(sexpr1, sexpr2)) a b
+        )in
+        let nt = (pack nt check_if_valid_list) in
+            nt s
+    and nt_quote s = 
+        let prefix = word "'" in
+        let nt = caten prefix nt_sexpr in
+        pack nt (function (_, e) -> Pair(Symbol("quote"), Pair(e, Nil)))
+        s
+    and nt_quasi_quote s = 
+        let prefix = word "`" in
+        let nt = caten prefix nt_sexpr in
+        pack nt (function (_, e) -> Pair(Symbol("quasiquote"), Pair(e, Nil)))
+        s
+    and nt_unquote s = 
+        let prefix = word "," in
+        let nt = caten prefix nt_sexpr in
+        pack nt (function (_, e) -> Pair(Symbol("unquote"), Pair(e, Nil)))
+        s
+    and nt_unquote_and_splice s = 
+        let prefix = word ",@" in
+        let nt = caten prefix nt_sexpr in
+        pack nt (function (_, e) -> Pair(Symbol("unquote-splicing"), Pair(e, Nil)))
+        s
+    and nt_tag_ref s =
+        let nt = pack nt_teg_ref_identifier (fun name -> TagRef(name)) in
+        nt s
+    and nt_tagged_sexpr s =
+        let eq_sign = word "=" in
+        let nt = caten nt_teg_ref_identifier eq_sign in
+        let nt = caten nt nt_sexpr in
+        let nt = pack nt (fun ((name,_),sexpr) -> TaggedSexpr(name, sexpr)) in
+        let nt = pack nt (fun e -> 
+            let rec check_if_valid original_name rec_sexpr = match rec_sexpr with
+                |TaggedSexpr(some_name, some_sexpr) -> 
+                    if some_name = original_name 
+                        then false
+                        else (check_if_valid original_name some_sexpr)
+                |Pair(sexpr1, sexpr2) -> 
+                    (check_if_valid original_name sexpr1) &&
+                    (check_if_valid original_name sexpr2) 
+                |other -> true in
+
+            match e with
+            | TaggedSexpr(name, sexpr) -> let valid = check_if_valid name sexpr in
+            if valid then TaggedSexpr(name, sexpr) else raise X_this_should_not_happen
+            | other -> raise X_no_match ) in
+            nt s
+    and nt_comment_sexpr s =
+        let prefix = word "#;" in
+        let body = nt_sexpr in
+        let nt = caten prefix body in
+        (pack nt (fun e -> Nil)) 
+        s
+    and nt_nil s = 
+        let prefix = char '(' in
+        let postfix = char ')' in
+        let body = disj_list [nt_comment_line; (pack nt_whitespace (fun e -> Nil));nt_comment_sexpr] in
+        let nt = caten prefix (caten (star body) postfix) in
+        let nt = pack nt (fun e -> Nil) in
+        nt s
+    and make_spaced_or_commented s = 
+        (* let nt_not_last_comment_sexpr = not_followed_by (pack nt_comment_sexpr (fun e -> Nil)) (pack (nt_end_of_input) (fun e -> Nil)) in *)
+        let whitespace_or_comment = disj_list [(pack nt_whitespace (fun e -> Nil));nt_comment_line;nt_comment_sexpr] in
+        let nt1 nt = make_paired (star whitespace_or_comment) (star whitespace_or_comment) nt in
+        nt1 s;;
+
+
+let read_sexpr string =
+  let (sexpr, s) = (nt_sexpr (string_to_list string)) in
+  if (s = [])
+  then sexpr
+  else raise X_no_match;;
+
+
+let read_sexprs string =
+    let (sexpr_list, s) = ((star nt_sexpr) (string_to_list string)) in
+    sexpr_list;;
 
-let read_sexprs string = raise X_not_yet_implemented;;
-  
 end;; (* struct Reader *)
diff --git a/readme.txt b/readme.txt
index e69de29..60a6f31 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,10 @@
+Tamar Rosen 312275845
+Ronen Krishtal 311303572
+
+We assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the Internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+action.
\ No newline at end of file
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 2f5ff59..1f73ddb 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -52,24 +52,391 @@ let rec expr'_eq e1 e2 =
                        
 exception X_syntax_error;;
 
-module type SEMANTICS = sig
+module type SEMANTICS = 
+sig
   val run_semantics : expr -> expr'
   val annotate_lexical_addresses : expr -> expr'
   val annotate_tail_calls : expr' -> expr'
   val box_set : expr' -> expr'
 end;;
 
-module Semantics : SEMANTICS = struct
+module Semantics 
+: SEMANTICS 
+= struct
+      
+let rec annotate_bound_major string_var arg_lists major_level = 
+  let rec annotate_bound_minor string_var arg_list minor_level = match arg_list with
+  | car :: cdr -> if String.equal car string_var then Some(minor_level) else annotate_bound_minor string_var cdr (minor_level + 1)
+  | _ -> None in
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+match arg_lists with
+| [arg_list :: cdr] -> let minor = annotate_bound_minor string_var arg_list 0 in (match minor with 
+   | Some(minor_level) -> if (major_level < 0) then Var'(VarParam(string_var, minor_level)) else Var'(VarBound(string_var, major_level, minor_level))
+   | None -> annotate_bound_major string_var [cdr] (major_level + 1))
+| _ -> Var'(VarFree(string_var))
+ ;;
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
+let rec annotate_lexical_rec e = match e with
+  | Const(constant) -> Const'(constant)
+  | Var(string) -> Var'(VarFree(string))
+  | If(test, dit, dif) -> If'(annotate_lexical_rec test, annotate_lexical_rec dit, annotate_lexical_rec dif)
+  | Seq(expr_list) -> Seq'(List.map annotate_lexical_rec expr_list)
+  | Set(expr_var, expr_val) -> Set'(annotate_lexical_rec expr_var,annotate_lexical_rec expr_val)
+  | Def(expr_var, expr_val) -> Def'(annotate_lexical_rec expr_var,annotate_lexical_rec expr_val)
+  | Or(expr_list) -> Or'(List.map annotate_lexical_rec expr_list)
+  | Applic(expr, expr_list) -> Applic'(annotate_lexical_rec expr,List.map annotate_lexical_rec expr_list)
+  | LambdaSimple(arg_list, body) -> let annotated_body = (annotate_lambda_simple [arg_list] body) in LambdaSimple'(arg_list,annotated_body)
+  | LambdaOpt(arg_list, opt_arg, body) -> let annotated_body = annotate_lambda_simple [arg_list@[opt_arg]] body in 
+  LambdaOpt'(arg_list, opt_arg, annotated_body)
 
-let box_set e = raise X_not_yet_implemented;;
+  and annotate_lambda_simple arg_lists body = match body with
+  | Const(constant) -> Const'(constant)
+  | Var(str) -> annotate_bound_major str [arg_lists] (-1)
+  | If(test, dit, dif) -> If'(annotate_lambda_simple arg_lists test, annotate_lambda_simple arg_lists dit, annotate_lambda_simple arg_lists dif)
+  | Seq(expr_list) -> Seq'(List.map (annotate_lambda_simple arg_lists) expr_list)
+  | Set(expr_var, expr_val) -> Set'(annotate_lambda_simple arg_lists expr_var,annotate_lambda_simple arg_lists expr_val)
+  | Def(expr_var, expr_val) -> Def'(annotate_lambda_simple arg_lists expr_var,annotate_lambda_simple arg_lists expr_val)
+  | Or(expr_list) -> Or'(List.map (annotate_lambda_simple arg_lists) expr_list)
+  | Applic(expr, expr_list) -> Applic'(annotate_lambda_simple arg_lists expr,List.map (annotate_lambda_simple arg_lists) expr_list)
+  | LambdaSimple(arg_list, inner_body) -> let annotated_body = annotate_lambda_simple ([arg_list]@arg_lists) inner_body in LambdaSimple'(arg_list,annotated_body)
+  | LambdaOpt(arg_list, opt_arg, inner_body) -> let annotated_body = annotate_lambda_simple ([arg_list @ [opt_arg]]@arg_lists) inner_body 
+  in  LambdaOpt'(arg_list, opt_arg, annotated_body)
+  ;;
+
+let rec annotate_tail_rec in_tp e = match e with
+  | If'(test, dit, dif) -> If'(annotate_tail_rec false test, annotate_tail_rec in_tp dit, annotate_tail_rec in_tp dif)
+  | Seq'(expr_list) -> annotate_seq in_tp expr_list
+  | Set'(expr_var, expr_val) -> Set'(annotate_tail_rec false expr_var,annotate_tail_rec false expr_val)
+  | Def'(expr_var, expr_val) -> Def'(annotate_tail_rec false expr_var,annotate_tail_rec false expr_val)
+  | Or'(expr_list) -> annotate_or in_tp expr_list
+  | Applic'(expr, expr_list) -> if in_tp then ApplicTP'(annotate_tail_rec false expr,List.map (annotate_tail_rec false) expr_list) else Applic'(annotate_tail_rec false expr,List.map (annotate_tail_rec false) expr_list)
+  | LambdaSimple'(arg_list, body) -> LambdaSimple'(arg_list, annotate_tail_rec true body)
+  | LambdaOpt'(arg_list, opt_arg, body) -> LambdaOpt'(arg_list, opt_arg, annotate_tail_rec true body)
+  | other -> other
+
+and annotate_seq in_tp expr_list = (match (List.rev expr_list) with 
+    | car :: cdr -> Seq'((List.map (annotate_tail_rec false) (List.rev cdr)) @ [(annotate_tail_rec in_tp car)])
+    | _ -> Seq'((List.map (annotate_tail_rec false) expr_list)))
+
+and annotate_or in_tp expr_list = (match (List.rev expr_list) with 
+    | car :: cdr -> Or'((List.map (annotate_tail_rec false) (List.rev cdr)) @ [(annotate_tail_rec in_tp car)])
+    | _ -> Or'((List.map (annotate_tail_rec false) expr_list)))
+
+
+let rec append_list l1 l2 =
+    match l1 with
+    | [] -> l2
+    | h::t -> if List.mem h l2 then append_list t l2
+              else append_list t (h::l2);;
+
+let append_inner_lists l1 l2 = match l1, l2 with
+| left1::[right1], left2::[right2] -> [append_list left1 left2;append_list right1 right2]
+|(l1, []) -> l1
+|([], l2) -> l2
+| other -> [];;
+
+let rec print_list = function 
+[] -> ()
+| e::l -> print_int e ; print_string " " ; print_list l;;
+
+  type counter = { get : unit -> int;
+                     incr : unit -> unit };;
+
+let find_fathers minor arg body = 
+
+  let father_id =
+    let n = ref 0 in
+    { get = (fun () -> !n);
+      incr = (fun () -> n:= !n +1) } in
+
+  let rec find_rw_fathers level arg body = 
+    (* Printf.printf "father %d level %d arg %s\n" (father_id.get ()) level arg; *)
+    match body with
+    | Var'(VarParam(str, minor)) -> if level = (-1) 
+      then if String.equal str arg then [[-1];[]] else [[];[]]
+      else [[];[]]
+
+    | Var'(VarBound(str, major, minor)) -> if level = major
+      then if String.equal str arg then [[(father_id.get ())];[]] else [[];[]]
+      else [[];[]]
+
+    | Set'(var, expr) -> 
+      (match var, expr with
+      | Var'(VarParam(str1, minor1)), Var'(VarParam(str2, minor2)) -> if level = (-1)
+        then if String.equal str1 arg 
+            then if String.equal str2 arg then [[-1];[-1]] else [[];[-1]]
+            else if String.equal str2 arg then [[-1];[]] else [[];[]]
+        else [[];[]]
+      | Var'(VarBound(str1, major1, minor1)), Var'(VarBound(str2, major2, minor2)) -> 
+        if level = major1
+              (*write matches level*)
+              then if String.equal str1 arg 
+                    (*write matches name*)
+                    then if level = major2 
+                        (*read matches level*)
+                        then if String.equal str2 arg then [[(father_id.get ())];[(father_id.get ())]] else [[];[(father_id.get ())]]
+                        (*read doesn't matches level*)
+                        else [[];[(father_id.get ())]]
+                    (*write doesn't name*)
+                    else if level = major2 
+                        (*read matches level*)
+                        then if String.equal str2 arg then [[(father_id.get ())];[]] else [[];[]]
+                        (*read doesn't matches level*)
+                        else [[];[]]
+              (*write doesn't matches level*)
+              else if level = major2 
+                        (*read matches level*)
+                        then if String.equal str2 arg then [[(father_id.get ())];[]] else [[];[]]
+                        (*read doesn't matches level*)
+                        else [[];[]]
+      | Var'(VarBound(str1, major, minor1)), Var'(VarParam(str2, minor2)) ->  if level = major
+            (*write matches level*)
+            then if String.equal str1 arg 
+                  (*write matches name*)
+                  then [[];[(father_id.get ())]]
+                  (*write doesn't match name*)
+                  else [[];[]]
+            (*write doesn't matches level*)
+            else [[];[]]
+      | Var'(VarParam(str1, minor1)), Var'(VarBound(str2, major, minor2)) -> if level = major
+            (*read matches level*)
+            then if String.equal str2 arg 
+                  (*read matches name*)
+                  then [[(father_id.get ())];[]]
+                  (*read doesn't match name*)
+                  else [[];[]]
+            (*read doesn't matches level*)
+            else [[];[]]
+      | Var'(VarParam(str, minor)), not_var -> if level = -1
+        (*write matches level*)
+        then if String.equal str arg 
+              (*write matches name*)
+              then let result = find_rw_fathers level arg not_var in match result with
+              | read_list::[write_list] -> [read_list;[-1]@write_list]
+              | other -> other
+              (*write doesn't matches name*)
+              else find_rw_fathers level arg not_var
+        (*write doesn't matches level*)
+        else find_rw_fathers level arg not_var
+      | Var'(VarBound(str, major,minor)), not_var -> 
+      if level = major
+        (*write matches level*)
+        then if String.equal str arg 
+              (*write matches name*)
+              then let result = find_rw_fathers level arg not_var in  match result with
+              | read_list::[write_list] -> [read_list;[(father_id.get ())]@write_list]
+              | other -> other
+              (*write doesn't matches name*)
+              else find_rw_fathers level arg not_var
+        (*write doesn't matches level*)
+        else find_rw_fathers level arg not_var
+      | Var'(VarFree(str)), expr -> find_rw_fathers level arg expr
+      | other -> [[];[]]
+      )
+
+    | If'(test, dit, dif) -> 
+      let fathers_test = find_rw_fathers level arg test in
+      let fathers_dit = find_rw_fathers level arg dit in
+      let fathers_dif = find_rw_fathers level arg dif in
+      (match fathers_test, fathers_dit, fathers_dif with
+      | [read_test;write_test],[read_dit;write_dit],[read_dif;write_dif] ->  [read_test@read_dit@read_dif;write_test@write_dit@write_dif]
+      | other -> [[];[]])
+
+    | Seq'(expr_list) -> 
+      let expr_list_rec = List.map (find_rw_fathers level arg) expr_list in
+      List.fold_right append_inner_lists expr_list_rec []
+    | Or'(expr_list) -> 
+      let expr_list_rec = List.map (find_rw_fathers level arg) expr_list in
+      List.fold_right append_inner_lists expr_list_rec []
+    | Applic'(expr, expr_list) -> 
+      let expr_rec = find_rw_fathers level arg expr in
+      let expr_list_rec = List.map (find_rw_fathers level arg) expr_list in
+      let expr_list_appended = List.fold_right append_inner_lists expr_list_rec [] in
+      append_inner_lists expr_rec expr_list_appended
+    | ApplicTP'(expr, expr_list) -> 
+      let expr_rec = find_rw_fathers level arg expr in
+      let expr_list_rec = List.map (find_rw_fathers level arg) expr_list in
+      let expr_list_appended = List.fold_right append_inner_lists expr_list_rec [] in
+      append_inner_lists expr_rec expr_list_appended
+    | LambdaSimple'(arg_list, inner_body) -> if level = (-1) then father_id.incr (); find_rw_fathers (level + 1) arg inner_body
+    | LambdaOpt'(arg_list, opt_arg, inner_body) -> if level = (-1) then father_id.incr (); find_rw_fathers (level + 1) arg inner_body
+    | Def'(expr_var, expr_val) -> raise X_syntax_error
+    | other -> [[];[]]  in
+
+  find_rw_fathers (-1) arg body;;
+
+  
+let rec box_get_set_body level arg body = 
+match body with
+    | Var'(VarParam(str, minor)) -> if level = (-1) 
+      then if String.equal str arg then BoxGet'(VarParam(str, minor)) else body
+      else body
+
+    | Var'(VarBound(str, major, minor)) -> 
+    if level = major
+      then if String.equal str arg then BoxGet'(VarBound(str, major, minor)) else body
+      else body
+
+    | Set'(var, expr) -> 
+      (match var, expr with
+      | Var'(VarParam(str1, minor1)), Var'(VarParam(str2, minor2)) -> if level = (-1)
+        then if String.equal str1 arg 
+            then if String.equal str2 arg then BoxSet'(VarParam(str1, minor1), BoxGet'(VarParam(str2, minor2))) else BoxSet'(VarParam(str1, minor1), expr)
+            else if String.equal str2 arg then Set'(var, BoxGet'(VarParam(str2, minor2))) else body
+        else body
+      | Var'(VarBound(str1, major1, minor1)), Var'(VarBound(str2, major2, minor2)) -> 
+        if level = major1
+              (*write matches level*)
+              then if String.equal str1 arg 
+                    (*write matches name*)
+                    then if level = major2 
+                        (*read matches level*)
+                        then if String.equal str2 arg then BoxSet'(VarBound(str1, major1, minor1), BoxGet'(VarBound(str2, major2, minor2))) else BoxSet'(VarBound(str1, major1, minor1), expr)
+                        (*read doesn't matches level*)
+                        else BoxSet'(VarBound(str1, major1, minor1), expr)
+                    (*write doesn't match name*)
+                    else if level = major2 
+                        (*read matches level*)
+                        then if String.equal str2 arg then Set'(var, BoxGet'(VarBound(str2, major2, minor2))) else body
+                        (*read doesn't matches level*)
+                        else body
+              (*write doesn't matches level*)
+              else if level = major2 
+                        (*read matches level*)
+                        then if String.equal str2 arg then Set'(var, BoxGet'(VarBound(str2, major2, minor2))) else body
+                        (*read doesn't matches level*)
+                        else body
+      | Var'(VarBound(str1, major, minor1)), Var'(VarParam(str2, minor2)) ->  if level = major
+            (*write matches level*)
+            then if String.equal str1 arg 
+                  (*write matches name*)
+                  then BoxSet'(VarBound(str1, major, minor1), expr)
+                  (*write doesn't match name*)
+                  else body
+            (*write doesn't matches level*)
+            else body
+      | Var'(VarParam(str1, minor1)), Var'(VarBound(str2, major, minor2)) -> if level = major
+            (*read matches level*)
+            then if String.equal str2 arg 
+                  (*read matches name*)
+                  then Set'(var, BoxGet'(VarBound(str2, major, minor2)))
+                  (*read doesn't match name*)
+                  else body
+            (*read doesn't matches level*)
+            else body
+      | Var'(VarParam(str, minor)), not_var -> 
+        let result_body = box_get_set_body level arg not_var in
+        if level = -1
+        (*write matches level*)
+        then if String.equal str arg 
+              (*write matches name*)
+              then BoxSet'(VarParam(str, minor), result_body)
+              (*write doesn't matches name*)
+              else Set'(var, result_body)
+        (*write doesn't matches level*)
+        else Set'(var, result_body)
+      | Var'(VarBound(str, major,minor)), not_var -> 
+        let result_body = box_get_set_body level arg not_var in
+        if level = major
+        (*write matches level*)
+        then if String.equal str arg 
+              (*write matches name*)
+              then BoxSet'(VarBound(str, major,minor), result_body)
+              (*write doesn't matches name*)
+              else Set'(var, result_body)
+        (*write doesn't matches level*)
+        else Set'(var, result_body)
+     
+      | Var'(VarFree(str)), expr -> Set'(Var'(VarFree(str)), box_get_set_body level arg expr)
+      | other -> body
+      )
+    | BoxSet'(var, expr) -> BoxSet'(var, box_get_set_body level arg expr)
+          
+          
+            
+    | If'(test, dit, dif) -> If'(box_get_set_body level arg test, box_get_set_body level arg dit, box_get_set_body level arg dif)
+    | Seq'(expr_list) -> Seq'(List.map (box_get_set_body level arg) expr_list)
+    | Or'(expr_list) -> Or'(List.map (box_get_set_body level arg) expr_list )
+    | Applic'(expr, expr_list) -> Applic'((box_get_set_body level arg) expr,List.map (box_get_set_body level arg) expr_list)
+    | ApplicTP'(expr, expr_list) -> ApplicTP'((box_get_set_body level arg) expr,List.map (box_get_set_body level arg) expr_list)
+    | LambdaSimple'(arg_list, inner_body) -> LambdaSimple'(arg_list, (box_get_set_body (level+1) arg) inner_body)
+    | LambdaOpt'(arg_list, opt_arg, inner_body) -> LambdaOpt'(arg_list, opt_arg, (box_get_set_body (level+1) arg) inner_body)
+    | Def'(expr_var, expr_val) -> raise X_syntax_error
+    | other -> body;;
+
+let handle_arg minor arg body = 
+    let need_boxing read_list write_list = 
+    let rec need_boxing_rec ls1 ls2 = 
+    (match ls1, ls2 with
+      | [], [] -> false
+      | [] , other -> true
+      | other , [] -> true
+      | arg1::rest1, arg2::rest2 -> if (List.mem arg1 ls2) 
+                                    (*arg1 is in l2*)
+                                        (*arg1 is in l2 AND arg2 is in l1*)
+                                        then (false || need_boxing_rec rest1 (List.filter (fun a -> a!=arg1) ls2)) 
+                                        (*arg1 is in l2 AND arg2 is NOT in l1*)
+                                        else true ) in
+    match read_list, write_list with
+    | [] , other -> false
+    | other , [] -> false
+    | non_empty1, non_empty2 -> need_boxing_rec non_empty1 non_empty2 in
+
+  let fathers = find_fathers minor arg body in
+
+    match fathers with
+  | [read_list;write_list] ->  if need_boxing read_list write_list then true else false
+  | other -> false
+
+let box_set_lambda arg_list body =
+
+  let rec args_to_set_box_list minor arg_list body = match arg_list with
+    | car :: cdr -> 
+    let needs_boxing = handle_arg minor car body in if needs_boxing 
+      then
+          let set_box_car = Set'(Var'(VarParam(car, minor)), Box'((VarParam(car, minor)))) in
+          let set_box_cdr = args_to_set_box_list (minor+1) cdr body in ([set_box_car] @ set_box_cdr)
+
+      else args_to_set_box_list (minor+1) cdr body
+    | [] -> [] in
+  
+
+  let rec box_get_set_all_args minor arg_list rec_body = match arg_list with
+    | car :: cdr -> 
+    let needs_boxing = handle_arg minor car body in if needs_boxing 
+      then let new_body = box_get_set_body (-1) car rec_body in box_get_set_all_args (minor + 1) cdr new_body
+      else box_get_set_all_args (minor + 1) cdr rec_body
+    | [] -> rec_body in
+
+  let set_box_list = args_to_set_box_list 0 arg_list body in
+  let new_body = box_get_set_all_args 0 arg_list body in
+  match set_box_list with
+  | [] -> body
+  | list -> Seq'(set_box_list@[new_body])
+
+   ;;
+
+let rec box_set_rec e = match e with
+  | If'(test, dit, dif) -> If'(box_set_rec test, box_set_rec dit, box_set_rec dif)
+  | Seq'(expr_list) -> Seq'(List.map box_set_rec expr_list)
+  | Set'(expr_var, expr_val) -> Set'(box_set_rec expr_var,box_set_rec expr_val)
+  | Def'(expr_var, expr_val) -> Def'(box_set_rec expr_var,box_set_rec expr_val)
+  | Or'(expr_list) -> Or'(List.map box_set_rec expr_list)
+  | Applic'(expr, expr_list) -> Applic'(box_set_rec expr, List.map box_set_rec expr_list) 
+  | ApplicTP'(expr, expr_list) -> ApplicTP'(box_set_rec expr, List.map box_set_rec expr_list) 
+  | LambdaSimple'(arg_list, body) -> LambdaSimple'(arg_list,box_set_rec (box_set_lambda arg_list body))
+  | LambdaOpt'(arg_list, opt_arg, body) -> LambdaOpt'(arg_list, opt_arg, box_set_rec (box_set_lambda (arg_list@[opt_arg]) body))
+  | other -> other;; 
+
+let annotate_lexical_addresses e = annotate_lexical_rec e;;
+
+let annotate_tail_calls e = annotate_tail_rec false e;;
+  
+let box_set e = box_set_rec e;;
 
 let run_semantics expr =
   box_set
     (annotate_tail_calls
        (annotate_lexical_addresses expr));;
-  
-end;; (* struct Semantics *)
+
+end;; (* struct Semantics *)
\ No newline at end of file
diff --git a/stdlib.scm b/stdlib.scm
index 8bce64b..6ddf569 100644
--- a/stdlib.scm
+++ b/stdlib.scm
@@ -12,19 +12,41 @@
       map-loop)))
 
 (define fold-left
-  #;(Add your implementation here
-     Note: The file won't compile like this, beacuase your tag-parser requires define to have a second expression.
-     This is on purpose, so you don't compile the library without completing this implementation by mistake.))
+(let ((null? null?)
+	(car car)
+	(cdr cdr))
+ (letrec ((fold-left-loop  (lambda (f acc list)
+  (if (null? list)
+      acc
+      (fold-left f
+             (f acc (car list))
+             (cdr list))))))
+      fold-left-loop)))
 
 (define fold-right
-  #;(Add your implementation here
-     Note: The file won't compile like this, beacuase your tag-parser requires define to have a second expression.
-     This is on purpose, so you don't compile the library without completing this implementation by mistake.))
+(let ((null? null?)
+	(car car)
+	(cdr cdr))
+ (letrec ((fold-right-loop  (lambda (f acc list)
+  (if (null? list)
+      acc
+      (f (car list)
+         (fold-right f acc (cdr list)))))))
+      fold-right-loop)))
 
 (define cons*
-  #;(Add your implementation here
-     Note: The file won't compile like this, beacuase your tag-parser requires define to have a second expression.
-     This is on purpose, so you don't compile the library without completing this implementation by mistake.))
+(let ((null? null?)
+	(cons cons)
+	(car car)
+	(cdr cdr))
+	(lambda x
+		(fold-right
+		(lambda (a acc)
+			(if (null? acc)
+			a
+			(cons a acc)))
+		'()
+		x))))
 
 (define append
   (let ((null? null?)
diff --git a/tag-parser.ml b/tag-parser.ml
index 712f408..25ad6be 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -1,6 +1,16 @@
 #use "reader.ml";;
+open Reader;;
 
-type constant =
+type constant = 
+(*
+quoted and unquoted: Pair(Symbol(name), Pair(sexpr, Nil())
+booleans
+chars
+numbers
+strings
+tag def -> field is always a const. if the field is quote, it should not appear in the Const we generate.
+tag ref
+*)
   | Sexpr of sexpr
   | Void
 
@@ -44,12 +54,16 @@ let rec expr_eq e1 e2 =
                        
 exception X_syntax_error;;
 
-module type TAG_PARSER = sig
+module type TAG_PARSER = 
+sig
   val tag_parse_expression : sexpr -> expr
   val tag_parse_expressions : sexpr list -> expr list
-end;; (* signature TAG_PARSER *)
+end;; 
+(* signature TAG_PARSER *)
 
-module Tag_Parser : TAG_PARSER = struct
+module Tag_Parser 
+(* : TAG_PARSER  *)
+= struct
 
 let reserved_word_list =
   ["and"; "begin"; "cond"; "define"; "else";
@@ -59,9 +73,269 @@ let reserved_word_list =
 
 (* work on the tag parser starts here *)
 
-let tag_parse_expression sexpr = raise X_not_yet_implemented;;
+let rec convert_pairs_to_list sexpr = match sexpr with
+| Pair(car, cdr) -> List.append [car] (convert_pairs_to_list cdr)
+| Nil -> []
+| other -> [other]
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+let rec convert_pairs_to_str_list sexpr = 
+  let flat_list = convert_pairs_to_list sexpr in
+  List.map (fun e -> match e with
+  |Symbol(str)->str
+  |_ -> raise X_syntax_error)
+   flat_list;;
+
+let rec check_arg_reoccurrence lst = 
+  let rec check_if_args_exists arg rest = match rest with
+  | car :: cdr -> if car = arg then true else check_if_args_exists arg cdr
+  | [] -> false in
+match lst with
+| car :: cdr -> if (check_if_args_exists car cdr) then true else check_arg_reoccurrence cdr
+| [] -> false
+
+
+let rec is_proper_list sexpr = match sexpr with
+    | Pair(car, cdr) -> is_proper_list cdr
+    | Nil -> true
+    | _ -> false
+
+let get_first_element lst = match lst with
+    | car :: cdr -> car
+    | [] -> "empty list";;
+
+let get_last_element lst = 
+    let rev_lst = List.rev lst in match rev_lst with
+    | car :: cdr -> car
+    | [] -> "empty list";;
+
+let rec remove_last_element lst = match lst with
+    | [x] -> []
+    | car :: cdr -> List.append [car] (remove_last_element cdr)
+    | [] -> [];;
+
+let rec remove_first_element lst = match lst with
+| [x] -> []
+| car :: cdr -> cdr
+| [] -> [];;
+
+let tag_parse_var str = 
+      let is_reserved_word = List.mem str reserved_word_list in
+          if is_reserved_word then raise X_syntax_error else Var(str);;
+
+let rec ribs_to_var_list ribs = match ribs with
+| Pair(Symbol v, _) -> Pair(Symbol v, Nil)
+| Pair(Pair(Symbol v, _), rest) -> Pair(Symbol v, (ribs_to_var_list rest))
+| Nil -> Nil
+| _ -> raise X_syntax_error;;
+
+let rec ribs_to_val_list ribs = match ribs with
+| Pair(Symbol _,Pair( sexpr , Nil)) -> Pair(sexpr, Nil)
+| Pair(Pair(Symbol _,Pair(sexpr,Nil)), rest) -> Pair(sexpr, (ribs_to_val_list rest))
+| Nil -> Nil
+| _ -> raise X_syntax_error;;
+
+let rec change_to_whatever ribs = match ribs with
+| Pair(Symbol e,Pair( sexpr , Nil)) ->  Pair(Symbol e, Pair(Symbol("quote"), Pair(Symbol("whatever"), Nil)))
+| Pair(Pair(Symbol e,Pair(sexpr,Nil)), rest) -> 
+  Pair(Pair(Symbol e,Pair(Pair(Symbol("quote"), Pair(Symbol("whatever"), Nil)),Nil)), (change_to_whatever rest))
+| Nil -> Nil
+| _ -> raise X_syntax_error;;
+
+let rec wrap_ribs_in_set ribs body = match ribs with
+|Pair(Pair(var,Pair(sexpr_val, Nil)),Nil) -> Pair(Pair(Symbol "set!", Pair(var, Pair(sexpr_val, Nil))), body)
+|Pair(Pair(var,Pair(sexpr_val,Nil)), rest) -> Pair(Pair(Symbol "set!", Pair(var, Pair(sexpr_val, Nil))), (wrap_ribs_in_set rest body))
+|Nil -> body
+| _ -> raise X_syntax_error;;
+
+
+let get_first_pair pairs = match pairs with
+    | Nil -> Nil
+    | Pair(car, cdr) -> car
+    | _ -> raise X_syntax_error
+
+let remove_first_pair pairs = match pairs with
+    | Nil -> Nil
+    | Pair(car, cdr) -> cdr
+    | _ -> raise X_syntax_error
+
+let rec parse_exp sexpr = match sexpr with
+(*constants*)
+  | Nil -> Const(Void)
+  | Bool(e) -> Const(Sexpr(Bool(e)))
+  | Char(e) -> Const(Sexpr(Char(e)))
+  | Number(e) -> Const(Sexpr(Number(e)))
+  | String(e) -> Const(Sexpr(String(e)))
+  | Pair(Symbol("quote"), Pair(e, Nil)) -> Const(Sexpr(e))
+  | Pair(Symbol("quasiquote"), Pair(e, Nil)) -> parse_exp (expand_quasiquote e)
+  | TagRef(e) -> Const(Sexpr(TagRef(e)))
+  | TaggedSexpr(e,Pair(Symbol "quote", Pair(x, Nil))) -> Const(Sexpr(TaggedSexpr(e, x)))
+  | TaggedSexpr(e,Pair(a,b)) -> Const(Sexpr(TaggedSexpr(e, Pair(a,b))))
+  | TaggedSexpr(e,Bool(x)) -> Const(Sexpr(TaggedSexpr(e, Bool(x))))
+  | TaggedSexpr(e,Char(x)) -> Const(Sexpr(TaggedSexpr(e, Char(x))))
+  | TaggedSexpr(e,Number(x)) -> Const(Sexpr(TaggedSexpr(e, Number(x))))
+  | TaggedSexpr(e,String(x)) -> Const(Sexpr(TaggedSexpr(e, String(x))))
+  | TaggedSexpr(e,TagRef(x)) -> Const(Sexpr(TaggedSexpr(e, TagRef(x))))
+(*variables*)
+  | Symbol(e) -> tag_parse_var e
+(*conditionals*)        
+  | Pair(Symbol("if"), Pair(test, Pair(dit, dif))) -> tag_parse_if test dit dif
+
+  | Pair(Symbol("cond"), ribs) -> parse_exp (expand_cond ribs)
+(*lambdas*)
+  | Pair(Symbol("lambda"), Pair(args, body)) -> tag_parse_lambda args body
+  | Pair(Symbol "let", Pair(ribs, body)) -> parse_exp (expand_let ribs body)
+  | Pair(Symbol "let*", Pair(ribs, body)) -> parse_exp (expand_let_star ribs body)
+  | Pair(Symbol "letrec", Pair(ribs, body)) -> parse_exp (expand_letrec ribs body)
+  (* Const(Sexpr((expand_let ribs body))) *)
+  (*or*)
+  | Pair(Symbol "or", bool_pairs) -> tag_parse_or bool_pairs
+  | Pair(Symbol "and", bool_pairs) -> parse_exp (expand_and bool_pairs)
+  (*MIT define*)
+  | Pair(Symbol "define", Pair(Pair(name, args), body)) -> parse_exp (expand_mit_def name args body)
+  (*define*)
+  | Pair(Symbol "define", Pair(name, sexpr)) -> tag_parse_define name sexpr
+  (*set*)
+  | Pair(Symbol "set!", Pair(name, Pair(sexpr, Nil))) -> Set((parse_exp name), (parse_exp sexpr))
+  (*sequence*)
+  | Pair(Symbol "begin", seq) -> tag_parse_seq_explicit seq
+  (*applic*)
+  | Pair(proc_sexpr, sexprs) ->  tag_parse_applic proc_sexpr sexprs
+  | other -> raise X_syntax_error
+
+  and tag_parse_if test dit dif = match dif with
+  | Nil -> If(parse_exp test, parse_exp dit, Const(Void))
+  | Pair(sexpr, Nil) -> If (parse_exp test, parse_exp dit, parse_exp sexpr)
+  |_ -> raise X_syntax_error
+
+  and tag_parse_define name sexpr = match sexpr with
+  | Nil ->  Def((parse_exp name), Const(Void))
+  | Pair(a, Nil)-> Def((parse_exp name), (parse_exp a))
+  | other -> raise X_syntax_error
+
+  and tag_parse_lambda args body =
+  let body_seq = (tag_parse_seq_implicit body) in
+   match args with
+      | Pair(car, cdr) -> let str_list = convert_pairs_to_str_list args in 
+        if (check_arg_reoccurrence str_list) then raise X_syntax_error;
+        if (is_proper_list args) then LambdaSimple(str_list, body_seq) else 
+        let lst_without_last_element = remove_last_element str_list in 
+        let last_element = get_last_element str_list in 
+        LambdaOpt(lst_without_last_element, last_element, body_seq)
+      | Symbol(str) -> LambdaOpt([], str, body_seq)
+      | Nil -> LambdaSimple([], body_seq)
+      | _ -> raise X_syntax_error
+
+  and tag_parse_or bool_pairs = match bool_pairs with
+  | Nil -> Const(Sexpr (Bool false))
+  | Pair (a,Nil) -> Const(Sexpr (a))
+  | Pair (a,b) -> let bool_list = List.map parse_exp (convert_pairs_to_list bool_pairs) in
+      Or(bool_list)
+  | _ -> raise X_syntax_error
+
+  and tag_parse_seq_explicit seq = match seq with 
+  | Nil -> Const Void
+  | Pair(a, Nil) -> parse_exp a
+  | Pair(a, b) -> let seq_expr = List.map parse_exp (convert_pairs_to_list seq) in Seq(seq_expr)
+  | _ -> raise X_syntax_error
+  
+   and tag_parse_seq_implicit seq = match seq with 
+  | Pair(a, Nil) -> parse_exp a
+  | Pair(a, b) -> let seq_expr = List.map parse_exp (convert_pairs_to_list seq) in Seq(seq_expr)
+  | _ -> raise X_syntax_error
+
+  and tag_parse_applic proc_sexpr sexprs =   
+    let proc_expr = parse_exp proc_sexpr in
+    let exprs = 
+    List.map parse_exp (convert_pairs_to_list sexprs) in
+    (* [Const(Sexpr(sexprs))] in     *)
+    Applic(proc_expr, exprs)
+
+  and expand_quasiquote e = match e with
+  | Pair(Symbol("unquote"), Pair(sexpr, Nil)) -> sexpr
+  | Pair(Symbol("unquote-splicing"), Pair(sexpr, Nil)) -> raise X_syntax_error
+  | Pair(Pair(Symbol("unquote-splicing"), Pair(sexpr, Nil)), x) -> Pair(Symbol("append"),Pair(sexpr,Pair((expand_quasiquote x),Nil)))
+  | Pair(x, Pair(Symbol("unquote-splicing"), Pair(sexpr, Nil))) -> Pair(Symbol("cons"),Pair((expand_quasiquote x),Pair(sexpr,Nil)))
+  | Pair(x, y) -> Pair(Symbol("cons"),Pair((expand_quasiquote x), Pair((expand_quasiquote y),Nil)))
+  | Nil -> Pair(Symbol("quote"), Pair(Nil, Nil))
+  | Symbol(x) -> Pair(Symbol("quote"), Pair(Symbol(x), Nil))
+  | other -> other
+
+  and expand_cond ribs = match ribs with
+  (*3rd form*)
+  | Pair(Pair(Symbol "else",seq), _) -> (Pair(Symbol("begin"),seq))
+  (*2nd form*)
+  | Pair(Pair(test, Pair(Symbol("=>"), Pair(expr_f, Nil))), Nil) -> 
+      Pair(Symbol "let", Pair(Pair(Pair(Symbol "value", Pair(test, Nil)),
+       Pair(Pair(Symbol "f", Pair(Pair(Symbol "lambda", Pair(Nil, Pair(expr_f, Nil))), Nil)), Nil)),
+        Pair(Pair(Symbol "if", Pair(Symbol "value", Pair(Pair(Pair(Symbol "f", Nil),
+         Pair(Symbol "value", Nil)), Nil))), Nil))) 
+
+  | Pair(Pair(test, Pair(Symbol("=>"), Pair(expr_f, Nil))), rest) -> let expanded_ribs = (expand_cond rest) in
+   Pair(Symbol "let", Pair(Pair(Pair(Symbol "value", Pair(test, Nil)), 
+   Pair(Pair(Symbol "f", Pair(Pair(Symbol "lambda", Pair(Nil, Pair(expr_f, Nil))), Nil)),
+    Pair(Pair(Symbol "rest", Pair(Pair(Symbol "lambda", Pair(Nil, Pair(expanded_ribs, Nil))), Nil)), Nil))),
+     Pair(Pair(Symbol "if", Pair(Symbol "value", Pair(Pair(Pair(Symbol "f", Nil), Pair(Symbol "value", Nil)),
+      Pair(Pair(Symbol "rest", Nil), Nil)))), Nil))) 
+  (*1st form*)
+  | Pair(Pair(test, seq), Nil) -> Pair(Symbol("if"), Pair(test, Pair(Pair(Symbol("begin"),seq), Nil)))
+  | Pair(Pair(test, seq), rest) -> let expanded_ribs = (expand_cond rest) in
+    (Pair(Symbol("if"), Pair(test , Pair(Pair(Symbol("begin"),seq) , Pair(expanded_ribs , Nil)))))
+  | _ -> raise X_syntax_error  
+
+  and expand_let ribs body = 
+  let var_list = ribs_to_var_list ribs in 
+  let val_list = ribs_to_val_list ribs in
+  let lambda_sexpr = Pair(Symbol("lambda"), Pair(var_list, body)) in
+  Pair(lambda_sexpr, val_list)
+
+  and expand_let_star ribs body = 
+    let rec handle_let_star_body rec_ribs rec_body vars vals =
+          match rec_ribs with
+        | Nil -> expand_let rec_ribs rec_body
+        | Pair(rib, Nil) -> expand_let rec_ribs rec_body
+        | Pair(rib, rest) ->
+        (
+          let first_var = Pair((get_first_pair vars),Nil) in 
+          let first_val = Pair((get_first_pair vals),Nil) in
+          let rest_vars = remove_first_pair vars in
+          let rest_vals = remove_first_pair vals in
+          let body = handle_let_star_body rest body rest_vars rest_vals in
+          let lambda_sexpr = Pair(Pair(Symbol("lambda"), Pair(first_var, Pair(body, Nil))),first_val) in
+          lambda_sexpr
+      )
+        | _ -> raise X_syntax_error in
+    let var_list = ribs_to_var_list ribs in 
+    let val_list = ribs_to_val_list ribs in
+    handle_let_star_body ribs body var_list val_list
+
+  and expand_letrec ribs body = match ribs with
+  | Nil -> expand_let ribs body
+  | Pair(rib, rest) -> 
+    let new_ribs = change_to_whatever ribs in
+    let set_body = wrap_ribs_in_set ribs body in
+    (* let l_body = Pair(Symbol "let", Pair(Nil, body)) in *)
+    let form = Pair(Symbol "let", Pair(new_ribs,set_body)) in
+    (* let complete_form = Pair(Symbol "let", Pair(new_ribs,new_body)) in *)
+    form
+  | _ -> raise X_syntax_error
+
+  and expand_and bool_pairs = match bool_pairs with
+  | Nil -> Bool(true)
+  | Pair(expr,Nil) -> expr
+  | Pair(expr1, rest) -> let dit = (expand_and rest) in
+    Pair(Symbol("if"), Pair(expr1, Pair(dit, Pair(Bool(false), Nil))))
+  | _ -> raise X_syntax_error
+
+  and expand_mit_def name args body = 
+  let lambda_form = Pair(Symbol "lambda", Pair(args, body)) in
+  let form = Pair(Symbol "define", Pair(name, Pair(lambda_form,Nil))) in form
+;;
+
+
+
+let tag_parse_expression sexpr = parse_exp sexpr;;
+
+let tag_parse_expressions sexpr = List.map parse_exp sexpr;;
 
   
-end;; (* struct Tag_Parser *)
+end;; (* struct Tag_Parser *)
\ No newline at end of file
